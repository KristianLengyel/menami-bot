

# ===== bot.py =====

import os
from dotenv import load_dotenv
from menami.config import INTENTS, DROP_COOLDOWN_S
from menami.db import DB
from discord.ext import commands

load_dotenv()
TOKEN = os.getenv("DISCORD_TOKEN")
if not TOKEN:
    raise SystemExit("Missing DISCORD_TOKEN in .env")

class MenamiBot(commands.Bot):
    def __init__(self):
        super().__init__(command_prefix=commands.when_mentioned_or("m", "M", "!"), intents=INTENTS, case_insensitive=True)
        self.db = DB()
        self.channel_cooldowns: dict[int, float] = {}
        self.active_drops: dict[int, dict] = {}

    async def setup_hook(self):
        await self.db.init()
        await self.load_extension("menami.cogs.drops")
        await self.load_extension("menami.cogs.inventory")
        await self.load_extension("menami.cogs.helpcmd")
        await self.load_extension("menami.cogs.settings")
        await self.load_extension("menami.cogs.cooldowns")
        await self.load_extension("menami.cogs.wishlist")
        await self.tree.sync()

bot = MenamiBot()
bot.remove_command("help")

@bot.event
async def on_ready():
    print(f"Logged in as {bot.user} ({bot.user.id}) • cooldown={DROP_COOLDOWN_S}s")

if __name__ == "__main__":
    bot.run(TOKEN)


# ===== generate_project_summary.py =====

import os

# Folders to exclude
EXCLUDED_DIRS = {'.venv', '__pycache__', '.git', 'tools', 'assets', 'data'}
# Files to exclude
EXCLUDED_FILES = {'.gitignore', '.env'}

# Root folder name
ROOT_DIR = os.path.dirname(os.path.abspath(__file__))

structure_file = os.path.join(ROOT_DIR, 'project_structure.txt')
combined_file = os.path.join(ROOT_DIR, 'project_combined_scripts.txt')

def generate_structure(dir_path, prefix=""):
    entries = sorted(os.listdir(dir_path))
    tree_lines = []
    for index, entry in enumerate(entries):
        path = os.path.join(dir_path, entry)
        if entry in EXCLUDED_FILES or entry.startswith('.'):
            continue
        if os.path.isdir(path):
            if entry in EXCLUDED_DIRS:
                continue
            branch = "└── " if index == len(entries) - 1 else "├── "
            tree_lines.append(prefix + branch + entry + "/")
            extension = "    " if index == len(entries) - 1 else "│   "
            tree_lines.extend(generate_structure(path, prefix + extension))
        else:
            branch = "└── " if index == len(entries) - 1 else "├── "
            tree_lines.append(prefix + branch + entry)
    return tree_lines

def write_project_structure():
    lines = [os.path.basename(ROOT_DIR) + "/"]
    lines.extend(generate_structure(ROOT_DIR))
    with open(structure_file, 'w', encoding='utf-8') as f:
        f.write('\n'.join(lines))
    print(f"✅ Project structure saved to {structure_file}")

def combine_python_scripts():
    with open(combined_file, 'w', encoding='utf-8') as output:
        for root, dirs, files in os.walk(ROOT_DIR):
            # Skip unwanted folders
            dirs[:] = [d for d in dirs if d not in EXCLUDED_DIRS and not d.startswith('.')]
            for file in sorted(files):
                if file.endswith('.py') and file not in EXCLUDED_FILES:
                    path = os.path.join(root, file)
                    rel_path = os.path.relpath(path, ROOT_DIR)
                    output.write(f"\n\n# ===== {rel_path} =====\n\n")
                    with open(path, 'r', encoding='utf-8') as f:
                        output.write(f.read())
    print(f"✅ Combined .py scripts saved to {combined_file}")

if __name__ == "__main__":
    write_project_structure()
    combine_python_scripts()


# ===== menami\__init__.py =====

# makes 'menami' a package

# ===== menami\card_render.py =====

from __future__ import annotations
import io
from typing import Tuple
import aiohttp
import os
from PIL import Image, ImageDraw, ImageFont, ImageFilter

CARD_W, CARD_H = 274, 405
CUT_W, CUT_H = 211, 314
PAD = 10
IMG_BOX = (PAD, 70, CARD_W - PAD, CARD_H - 85)

FRAME_CUTOUTS: dict[int, tuple[int, int, int, int]] = {
    1: ((CARD_W - CUT_W) // 2, (CARD_H - CUT_H) // 2, CUT_W, CUT_H),
    2: ((CARD_W - CUT_W) // 2, (CARD_H - CUT_H) // 2, CUT_W, CUT_H),
    3: ((CARD_W - CUT_W) // 2, (CARD_H - CUT_H) // 2, CUT_W, CUT_H),
    4: ((CARD_W - CUT_W) // 2, (CARD_H - CUT_H) // 2, CUT_W, CUT_H),
    5: ((CARD_W - CUT_W) // 2, (CARD_H - CUT_H) // 2, CUT_W, CUT_H),
}

TEXT_BOXES: dict[int, dict[str, tuple[int, int, int, int]]] = {
    5: {
        "uid":    (58, 28, 114, 38),
        "name":   (65, 51, 208, 90),
        "series": (44, 303, 229, 347),
        "br":     (154, 360, 199, 370),
    },
    4: {
        "uid":    (62, 27, 117, 36),
        "name":   (61, 47, 212, 90),
        "series": (50, 301, 223, 352),
        "br":     (159, 361, 215, 372),
    },
    3: {
        "uid":    (63, 29, 118, 40),
        "name":   (65, 51, 208, 91),
        "series": (53, 307, 220, 350),
        "br":     (158, 360, 211, 372),
    },
    2: {
        "uid":    (64, 26, 117, 36),
        "name":   (54, 52, 219, 90),
        "series": (54, 308, 219, 347),
        "br":     (157, 363, 211, 372),
    },
    1: {
        "uid":    (57, 28, 111, 40),
        "name":   (59, 53, 214, 91),
        "series": (59, 310, 214, 348),
        "br":     (164, 359, 219, 371),
    },
}

BG_COLOR     = (18, 24, 38)
PANEL_COLOR  = (245, 238, 220)
PANEL_TEXT   = (30, 22, 18)
ACCENT       = (208, 180, 120)

FONT_PATH_BOLD = "assets/fonts/Alkia.ttf"
FONT_PATH_REG  = "assets/fonts/Alkia.ttf"

FRAME_DIR = "assets/frames"

def _text_boxes_for_set(set_id: int) -> tuple[
    tuple[int,int,int,int],  # uid
    tuple[int,int,int,int],  # name
    tuple[int,int,int,int],  # series
    tuple[int,int,int,int],  # serial+edition
]:
    spec = TEXT_BOXES.get(int(set_id))
    if not spec:
        uid_box    = (70, 0, 204, 22)
        name_box   = (18, 40, CARD_W - 18, 90)
        series_box = (18, CARD_H - 100, CARD_W - 18, CARD_H - 60)
        br_box     = (160, 385, 265, 405)
        return uid_box, name_box, series_box, br_box
    return spec["uid"], spec["name"], spec["series"], spec["br"]

def _cutout_for_set(set_id: int) -> tuple[int, int, int, int]:
    return FRAME_CUTOUTS.get(int(set_id), ((CARD_W - CUT_W) // 2, (CARD_H - CUT_H) // 2, CUT_W, CUT_H))

def _load_frame_for_set(set_id: int) -> Image.Image | None:
    path = os.path.join(FRAME_DIR, f"{int(set_id)}.png")
    if not os.path.exists(path):
        return None
    try:
        im = Image.open(path).convert("RGBA")
        if im.size != (CARD_W, CARD_H):
            im = im.resize((CARD_W, CARD_H), Image.LANCZOS)
        return im
    except Exception:
        return None

async def _fetch_image(url: str) -> Image.Image:
    async with aiohttp.ClientSession() as s:
        async with s.get(url) as r:
            r.raise_for_status()
            b = await r.read()
    return Image.open(io.BytesIO(b)).convert("RGBA")

def _fit_cover(im: Image.Image, box: Tuple[int,int,int,int]) -> Image.Image:
    bw = box[2] - box[0]; bh = box[3] - box[1]
    iw, ih = im.size
    scale = max(bw/iw, bh/ih)
    imr = im.resize((int(iw*scale), int(ih*scale)), Image.LANCZOS)
    iw2, ih2 = imr.size
    left = (iw2 - bw) // 2; top = (ih2 - bh) // 2
    return imr.crop((left, top, left + bw, top + bh))

def _font_try(path: str, size: int) -> ImageFont.FreeTypeFont:
    try:
        return ImageFont.truetype(path, size)
    except Exception:
        return ImageFont.load_default()

def _fit_text_size(draw: ImageDraw.ImageDraw, text: str, font_path: str, max_w: int, max_h: int,
                   size_max: int, size_min: int) -> ImageFont.FreeTypeFont:
    size = size_max
    while size >= size_min:
        f = _font_try(font_path, size)
        tw = draw.textlength(text, font=f)
        th = f.getbbox(text)[3] - f.getbbox(text)[1]
        if tw <= max_w and th <= max_h:
            return f
        size -= 1
    return _font_try(font_path, size_min)

def _draw_centered_fit(draw: ImageDraw.ImageDraw, text: str, rect: tuple[int,int,int,int],
                       font_path: str, size_max: int, size_min: int, fill: tuple[int,int,int,int]):
    l, t, r, b = rect
    max_w = max(1, (r - l) - 2)
    max_h = max(1, (b - t) - 2)
    font = _fit_text_size(draw, text, font_path, max_w, max_h, size_max, size_min)
    tw = draw.textlength(text, font=font)
    th = font.getbbox(text)[3] - font.getbbox(text)[1]
    x = l + (max_w - tw) / 2
    y = t + (max_h - th) / 2
    draw.text((x, y), text, font=font, fill=fill)
    return font

def _round_rect(dst, rect, fill, radius=8, outline=None, outline_width=1):
    x0,y0,x1,y1 = rect
    rr = Image.new("RGBA", (x1-x0, y1-y0), (0,0,0,0))
    d = ImageDraw.Draw(rr)
    d.rounded_rectangle((0,0,rr.width-1, rr.height-1), radius=radius,
                        fill=fill, outline=outline, width=outline_width)
    dst.alpha_composite(rr, (x0,y0))

async def render_card_image(
    series: str,
    character: str,
    serial_number: int,
    set_id: int,
    card_uid: str,
    image_url: str | None,
    fmt="PNG"
) -> bytes:
    card = Image.new("RGBA", (CARD_W, CARD_H), (0, 0, 0, 0))

    art = None
    if image_url:
        try:
            async with aiohttp.ClientSession() as session:
                async with session.get(image_url) as resp:
                    if resp.status == 200:
                        data = await resp.read()
                        art = Image.open(io.BytesIO(data)).convert("RGBA")
        except Exception:
            art = None
    if art is None:
        art = Image.new("RGBA", (CUT_W, CUT_H), (230, 230, 230, 255))

    x, y, w, h = _cutout_for_set(set_id)
    scale = max(w / art.width, h / art.height)
    art = art.resize((int(art.width * scale), int(art.height * scale)), Image.LANCZOS)
    cx = (art.width - w) // 2
    cy = (art.height - h) // 2
    art = art.crop((cx, cy, cx + w, cy + h))
    card.alpha_composite(art, (x, y))

    frame = _load_frame_for_set(set_id)
    if frame is not None:
        card.alpha_composite(frame)

    draw = ImageDraw.Draw(card)

    BLACK  = (0, 0, 0, 255)
    YELLOW = (255, 215, 64, 255)
    WHITE  = (255, 255, 255, 255)

    uid_box, name_box, series_box, br_box = _text_boxes_for_set(set_id)

    _draw_centered_fit(draw, str(character), name_box, FONT_PATH_BOLD, size_max=22, size_min=12, fill=BLACK)
    _draw_centered_fit(draw, str(series), series_box, FONT_PATH_REG, size_max=18, size_min=10, fill=BLACK)
    _draw_centered_fit(draw, str(card_uid).upper(), uid_box, FONT_PATH_REG, size_max=12, size_min=8, fill=YELLOW)

    l, t, r, b = br_box
    max_w = max(1, (r - l) - 2)
    max_h = max(1, (b - t) - 2)

    serial_text = f"#{int(serial_number)} • "
    set_text    = str(int(set_id)).upper()

    size_serial = 12
    size_set    = 12
    min_serial  = 8
    min_set     = 7

    while True:
        f_serial = _font_try(FONT_PATH_REG, size_serial)
        f_set    = _font_try(FONT_PATH_REG, size_set)
        w_serial = draw.textlength(serial_text, font=f_serial)
        w_set    = draw.textlength(set_text,    font=f_set)
        h_serial = f_serial.getbbox(serial_text)[3] - f_serial.getbbox(serial_text)[1]
        h_set    = f_set.getbbox(set_text)[3]    - f_set.getbbox(set_text)[1]
        total_w  = w_serial + w_set
        total_h  = max(h_serial, h_set)
        if total_w <= max_w and total_h <= max_h:
            break
        if size_serial > min_serial: size_serial -= 1
        if size_set > min_set:       size_set    -= 1
        if size_serial == min_serial and size_set == min_set:
            break

    f_serial = _font_try(FONT_PATH_REG, size_serial)
    f_set    = _font_try(FONT_PATH_REG, size_set)
    w_serial = draw.textlength(serial_text, font=f_serial)
    w_set    = draw.textlength(set_text,    font=f_set)
    h_serial = f_serial.getbbox(serial_text)[3] - f_serial.getbbox(serial_text)[1]
    h_set    = f_set.getbbox(set_text)[3]    - f_set.getbbox(set_text)[1]
    total_w  = w_serial + w_set
    total_h  = max(h_serial, h_set)

    x_start = l + (max_w - total_w) / 2
    y_start = t + (max_h - total_h) / 2

    draw.text((x_start, y_start), serial_text, font=f_serial, fill=YELLOW)
    draw.text((x_start + w_serial, y_start), set_text, font=f_set, fill=WHITE)

    buf = io.BytesIO()
    card.save(buf, format=fmt)
    return buf.getvalue()

async def render_drop_triptych(db, cards: list[dict]) -> bytes:
    target_w, target_h = 836, 419
    padding = 20

    available_w = target_w - (2 * padding)
    available_h = target_h - (2 * padding)

    orig_w, orig_h = 274, 405

    scale = min(available_h / orig_h, (available_w / 3) / orig_w)
    card_w, card_h = int(orig_w * scale), int(orig_h * scale)

    total_card_w = card_w * 3
    remaining_w = target_w - total_card_w
    gap = remaining_w // 4

    canvas = Image.new("RGBA", (target_w, target_h), (0, 0, 0, 0))
    rendered_images: list[Image.Image] = []

    for c in cards:
        url = await db.get_character_image(c["series"], c["character"], int(c["set_id"]))
        if not url:
            url = await db.get_character_image_any(c["series"], c["character"])

        img_bytes = await render_card_image(
            series=c["series"],
            character=c["character"],
            serial_number=int(c["serial_number"]),
            set_id=int(c["set_id"]),
            card_uid=c["card_uid"],
            image_url=url,
            fmt="PNG",
        )
        im = Image.open(io.BytesIO(img_bytes)).convert("RGBA")
        im = im.resize((card_w, card_h), Image.LANCZOS)
        rendered_images.append(im)

    y = (target_h - card_h) // 2
    x = gap
    for im in rendered_images:
        canvas.alpha_composite(im, (x, y))
        x += card_w + gap

    out = io.BytesIO()
    canvas.save(out, format="WEBP")
    return out.getvalue()


# ===== menami\config.py =====

import discord

INTENTS = discord.Intents.default()
INTENTS.message_content = True
INTENTS.members = True

DB_PATH = "menami.db"

USER_DROP_COOLDOWN_S = 30
GRAB_COOLDOWN_S      = 5

DAILY_COOLDOWN_S = 24 * 60 * 60
DAILY_COINS_MIN, DAILY_COINS_MAX = 100, 500
DAILY_GEMS_MIN,  DAILY_GEMS_MAX  = 10,  30

DROP_COOLDOWN_S = 30
CLAIM_WINDOW_S = 60

WISHLIST_MAX = 15

STAR_MIN = 0
STAR_MAX = 4

STAR_WEIGHTS = [10, 20, 40, 20, 10]

EMOJIS = ["1️⃣", "2️⃣", "3️⃣"]

QUALITY_BY_STARS = {
    0: "damaged",
    1: "poor",
    2: "good",
    3: "excellent",
    4: "mint",
}

BURN_REWARD_BY_STARS = {
    0: 9,    # ☆☆☆☆
    1: 19,   # ★☆☆☆
    2: 30,   # ★★☆☆
    3: 63,   # ★★★☆
    4: 124,  # ★★★★
}

UPGRADE_RULES = {
    0: {"to": 1, "chance": 0.80, "gold": 50,  "dust": 5, "fail": "stay"},
    1: {"to": 2, "chance": 0.70, "gold": 100, "dust": 5, "fail": "damaged"},
    2: {"to": 3, "chance": 0.60, "gold": 250, "dust": 5, "fail": "damaged"},
    3: {"to": 4, "chance": 0.50, "gold": 500, "dust": 5, "fail": "damaged"},
}

# ===== menami\db.py =====

from __future__ import annotations
import json
import aiosqlite
import random
from datetime import datetime, timezone
from .config import DB_PATH, QUALITY_BY_STARS, BURN_REWARD_BY_STARS

def _utcnow_iso() -> str:
    return datetime.utcnow().replace(tzinfo=timezone.utc).isoformat()

def _parse_iso(ts: str) -> datetime:
    dt = datetime.fromisoformat(ts)
    if dt.tzinfo is None:
        dt = dt.replace(tzinfo=timezone.utc)
    return dt

class DB:
    def __init__(self, path: str = DB_PATH):
        self.path = path

    async def init(self):
        async with aiosqlite.connect(self.path) as db:
            await db.executescript("""
            PRAGMA foreign_keys=ON;
            PRAGMA journal_mode=WAL;

            CREATE TABLE IF NOT EXISTS users(
              user_id INTEGER PRIMARY KEY,
              coins   INTEGER NOT NULL DEFAULT 0,
              gems    INTEGER NOT NULL DEFAULT 0,
              tickets INTEGER NOT NULL DEFAULT 0,
              dust_damaged  INTEGER NOT NULL DEFAULT 0,
              dust_poor     INTEGER NOT NULL DEFAULT 0,
              dust_good     INTEGER NOT NULL DEFAULT 0,
              dust_excellent INTEGER NOT NULL DEFAULT 0,
              dust_mint     INTEGER NOT NULL DEFAULT 0
            );

            CREATE TABLE IF NOT EXISTS cards(
              card_uid TEXT PRIMARY KEY,
              serial_number INTEGER NOT NULL,
              stars INTEGER NOT NULL,
              set_id INTEGER NOT NULL,
              series TEXT NOT NULL,
              character TEXT NOT NULL,
              condition TEXT NOT NULL,
              dropped_at TEXT NOT NULL,
              dropped_in_server TEXT NOT NULL,
              dropped_by TEXT NOT NULL,
              grabbed_by TEXT,
              owned_by TEXT,
              grab_delay REAL
            );

            CREATE TABLE IF NOT EXISTS burns(
              card_uid   TEXT PRIMARY KEY,
              series     TEXT NOT NULL,
              character  TEXT NOT NULL,
              stars      INTEGER NOT NULL,
              set_id     INTEGER NOT NULL,
              grabbed_by TEXT,
              grab_delay REAL,
              owner_id   TEXT NOT NULL,
              burned_at  TEXT NOT NULL
            );

            CREATE TABLE IF NOT EXISTS tags(
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                user_id TEXT NOT NULL,
                name TEXT NOT NULL,
                emoji TEXT NOT NULL,
                UNIQUE(user_id, name)
            );

            CREATE TABLE IF NOT EXISTS card_tags(
                card_uid TEXT NOT NULL,
                tag_id INTEGER NOT NULL,
                PRIMARY KEY(card_uid),
                FOREIGN KEY(card_uid) REFERENCES cards(card_uid),
                FOREIGN KEY(tag_id) REFERENCES tags(id)
            );
                                   
            CREATE TABLE IF NOT EXISTS character_images(
                series    TEXT NOT NULL,
                character TEXT NOT NULL,
                set_id    INTEGER NOT NULL,
                image_url TEXT NOT NULL,
                bytes     INTEGER,
                mime      TEXT,
                updated_at TEXT NOT NULL,
                PRIMARY KEY(series, character, set_id)
            );

            CREATE TABLE IF NOT EXISTS meta(
              key TEXT PRIMARY KEY,
              value TEXT NOT NULL
            );

            CREATE TABLE IF NOT EXISTS series(
              id INTEGER PRIMARY KEY AUTOINCREMENT,
              name TEXT UNIQUE NOT NULL
            );

            CREATE TABLE IF NOT EXISTS characters(
              id INTEGER PRIMARY KEY AUTOINCREMENT,
              series_id INTEGER NOT NULL,
              name TEXT NOT NULL,
              FOREIGN KEY(series_id) REFERENCES series(id),
              UNIQUE(series_id, name)
            );

            CREATE TABLE IF NOT EXISTS guild_settings(
              guild_id TEXT PRIMARY KEY,
              drop_channel_id TEXT,
              drop_cooldown_s INTEGER
            );
                                   
            CREATE TABLE IF NOT EXISTS user_timers(
                user_id TEXT NOT NULL,
                key     TEXT NOT NULL,
                ts      TEXT NOT NULL,
                PRIMARY KEY(user_id, key)
            );
                                   
            CREATE TABLE IF NOT EXISTS wishlists(
                user_id  TEXT NOT NULL,
                series   TEXT NOT NULL,
                character TEXT NOT NULL,
                PRIMARY KEY(user_id, series, character)
            );
                                   
            CREATE INDEX IF NOT EXISTS idx_cards_owned_by ON cards(owned_by);
            CREATE INDEX IF NOT EXISTS idx_cards_series_character ON cards(series, character);
            CREATE INDEX IF NOT EXISTS idx_cards_series_character_set ON cards(series, character, set_id);
            CREATE INDEX IF NOT EXISTS idx_burns_series_character ON burns(series, character);
            CREATE INDEX IF NOT EXISTS idx_burns_series_character_set ON burns(series, character, set_id);
            CREATE INDEX IF NOT EXISTS idx_cards_owned_by_dropped_at ON cards(owned_by, dropped_at);
            CREATE INDEX IF NOT EXISTS idx_wish_series_char ON wishlists(series, character);
            CREATE INDEX IF NOT EXISTS idx_wish_user ON wishlists(user_id);

            CREATE UNIQUE INDEX IF NOT EXISTS uq_cards_series_character_set_serial
            ON cards(series, character, set_id, serial_number);
                                
            INSERT OR IGNORE INTO meta(key, value) VALUES('next_serial', '1');
            INSERT OR IGNORE INTO meta(key, value) VALUES('editions_max', '5');
            INSERT OR IGNORE INTO meta(key, value) VALUES('edition_weights', '[1,2,3,5,9]');
            """)
            cols_u = {row[1] for row in await (await db.execute("PRAGMA table_info(users)")).fetchall()}
            for col in ["gems", "tickets", "dust_damaged", "dust_poor", "dust_good", "dust_excellent", "dust_mint"]:
                if col not in cols_u:
                    await db.execute(f"ALTER TABLE users ADD COLUMN {col} INTEGER NOT NULL DEFAULT 0")
            cols_g = {row[1] for row in await (await db.execute("PRAGMA table_info(guild_settings)")).fetchall()}
            if "drop_cooldown_s" not in cols_g:
                await db.execute("ALTER TABLE guild_settings ADD COLUMN drop_cooldown_s INTEGER")
            await db.commit()

    async def _random_free_serial(self, series: str, character: str, set_id: int, *, max_tries: int = 50) -> int:
        for _ in range(max_tries):
            sn = random.randint(1, 9999)
            async with aiosqlite.connect(self.path) as db:
                cur = await db.execute(
                    """SELECT 1 FROM cards
                       WHERE series=? AND character=? AND set_id=? AND serial_number=? LIMIT 1""",
                    (series, character, set_id, sn),
                )
                if not await cur.fetchone():
                    return sn
        used = set()
        async with aiosqlite.connect(self.path) as db:
            cur = await db.execute(
                """SELECT serial_number FROM cards
                   WHERE series=? AND character=? AND set_id=?""",
                (series, character, set_id),
            )
            rows = await cur.fetchall()
            used.update(int(r[0]) for r in rows if r and r[0] is not None)
        for sn in range(1, 10000):
            if sn not in used:
                return sn
        raise RuntimeError("All serial numbers 1..9999 are taken for this edition.")

    async def get_drop_channel(self, guild_id: int) -> int | None:
        async with aiosqlite.connect(self.path) as db:
            cur = await db.execute("SELECT drop_channel_id FROM guild_settings WHERE guild_id=?", (str(guild_id),))
            row = await cur.fetchone()
            return int(row[0]) if row and row[0] is not None else None

    async def set_drop_channel(self, guild_id: int, channel_id: int | None):
        async with aiosqlite.connect(self.path) as db:
            await db.execute(
                "INSERT INTO guild_settings(guild_id, drop_channel_id) VALUES(?, ?) "
                "ON CONFLICT(guild_id) DO UPDATE SET drop_channel_id=excluded.drop_channel_id",
                (str(guild_id), str(channel_id) if channel_id is not None else None),
            )
            await db.commit()

    async def get_drop_cooldown(self, guild_id: int) -> int | None:
        async with aiosqlite.connect(self.path) as db:
            cur = await db.execute("SELECT drop_cooldown_s FROM guild_settings WHERE guild_id=?", (str(guild_id),))
            row = await cur.fetchone()
            return int(row[0]) if row and row[0] is not None else None

    async def set_drop_cooldown(self, guild_id: int, seconds: int | None):
        async with aiosqlite.connect(self.path) as db:
            await db.execute("INSERT INTO guild_settings(guild_id) VALUES(?) ON CONFLICT(guild_id) DO NOTHING", (str(guild_id),))
            await db.execute("UPDATE guild_settings SET drop_cooldown_s=? WHERE guild_id=?", (seconds, str(guild_id)))
            await db.commit()

    # ---------- wishlist ----------
    async def wishlist_count(self, user_id: int) -> int:
        async with aiosqlite.connect(self.path) as db:
            cur = await db.execute("SELECT COUNT(*) FROM wishlists WHERE user_id=?", (str(user_id),))
            row = await cur.fetchone()
            return int(row[0] or 0)

    async def list_wishlist(self, user_id: int) -> list[tuple[str, str]]:
        async with aiosqlite.connect(self.path) as db:
            cur = await db.execute("""
                SELECT series, character
                FROM wishlists
                WHERE user_id=?
                ORDER BY LOWER(series) ASC, LOWER(character) ASC
            """, (str(user_id),))
            rows = await cur.fetchall()
            return [(r[0], r[1]) for r in rows]

    async def add_wish(self, user_id: int, series: str, character: str) -> bool:
        series = (series or "").strip()
        character = (character or "").strip()

        canon = await self.find_canonical_series_character(series, character)
        if canon:
            series, character = canon

        async with aiosqlite.connect(self.path) as db:
            try:
                await db.execute("""
                    INSERT INTO wishlists(user_id, series, character)
                    VALUES(?,?,?)
                    ON CONFLICT(user_id, series, character) DO NOTHING
                """, (str(user_id), series, character))
                await db.commit()

                cur = await db.execute("""
                    SELECT 1 FROM wishlists
                    WHERE user_id=? AND series=? AND character=?
                    LIMIT 1
                """, (str(user_id), series, character))
                return await cur.fetchone() is not None
            except Exception:
                return False

    async def remove_wish(self, user_id: int, series: str | None, character: str) -> int:
        async with aiosqlite.connect(self.path) as db:
            if series:
                cur = await db.execute("""
                    DELETE FROM wishlists WHERE user_id=? AND LOWER(series)=LOWER(?) AND LOWER(character)=LOWER(?)
                """, (str(user_id), series, character))
            else:
                cur = await db.execute("""
                    DELETE FROM wishlists WHERE user_id=? AND LOWER(character)=LOWER(?)
                """, (str(user_id), character))
            await db.commit()
            return cur.rowcount or 0

    async def find_canonical_series_character(self, series: str, character: str) -> tuple[str, str] | None:
        async with aiosqlite.connect(self.path) as db:
            cur = await db.execute("""
                SELECT s.name, c.name
                FROM characters c
                JOIN series s ON c.series_id = s.id
                WHERE LOWER(s.name)=LOWER(?) AND LOWER(c.name)=LOWER(?)
                LIMIT 1
            """, (series, character))
            row = await cur.fetchone()
            return (row[0], row[1]) if row else None

    async def find_by_character_only(self, character: str) -> list[tuple[str, str]]:
        async with aiosqlite.connect(self.path) as db:
            cur = await db.execute("""
                SELECT s.name, c.name
                FROM characters c
                JOIN series s ON c.series_id = s.id
                WHERE LOWER(c.name)=LOWER(?)
                ORDER BY LOWER(s.name) ASC
            """, (character,))
            rows = await cur.fetchall()
            return [(r[0], r[1]) for r in rows]

    async def get_wishers_for(self, series: str, character: str) -> list[int]:
        async with aiosqlite.connect(self.path) as db:
            cur = await db.execute("""
                SELECT user_id FROM wishlists
                WHERE LOWER(series)=LOWER(?) AND LOWER(character)=LOWER(?)
            """, (series, character))
            rows = await cur.fetchall()
            return [int(r[0]) for r in rows]

    # ---------- timers ----------
    async def set_timer(self, user_id: int, key: str):
        ts = _utcnow_iso()
        async with aiosqlite.connect(self.path) as db:
            await db.execute("""
                INSERT INTO user_timers(user_id, key, ts) VALUES(?, ?, ?)
                ON CONFLICT(user_id, key) DO UPDATE SET ts=excluded.ts
            """, (str(user_id), key, ts))
            await db.commit()

    async def get_timer(self, user_id: int, key: str) -> str | None:
        async with aiosqlite.connect(self.path) as db:
            cur = await db.execute("SELECT ts FROM user_timers WHERE user_id=? AND key=?", (str(user_id), key))
            row = await cur.fetchone()
            return row[0] if row else None

    async def seconds_remaining(self, user_id: int, key: str, cooldown_s: int) -> int:
        ts = await self.get_timer(user_id, key)
        if not ts:
            return 0
        last = _parse_iso(ts)
        now  = datetime.utcnow().replace(tzinfo=timezone.utc)
        elapsed = (now - last).total_seconds()
        remain = int(max(0, cooldown_s - elapsed))
        return remain

    # ---------- currency helpers ----------
    async def add_currency(self, user_id: int, *, coins: int = 0, gems: int = 0):
        await self.ensure_user(user_id)
        async with aiosqlite.connect(self.path) as db:
            await db.execute("""
                UPDATE users SET coins = coins + ?, gems = gems + ? WHERE user_id=?
            """, (int(coins), int(gems), user_id))
            await db.commit()

    # ---- content helpers ----
    async def insert_series(self, name: str) -> int:
        async with aiosqlite.connect(self.path) as db:
            await db.execute("INSERT OR IGNORE INTO series(name) VALUES(?)", (name,))
            await db.commit()
            cur = await db.execute("SELECT id FROM series WHERE name=?", (name,))
            row = await cur.fetchone()
            return int(row[0])

    async def insert_character(self, series_name: str, character_name: str):
        async with aiosqlite.connect(self.path) as db:
            await db.execute("INSERT OR IGNORE INTO series(name) VALUES(?)", (series_name,))
            cur = await db.execute("SELECT id FROM series WHERE name=?", (series_name,))
            series_id = int((await cur.fetchone())[0])
            await db.execute("INSERT OR IGNORE INTO characters(series_id, name) VALUES(?, ?)", (series_id, character_name))
            await db.commit()

    async def random_series_character(self) -> tuple[str, str] | None:
        async with aiosqlite.connect(self.path) as db:
            cur = await db.execute("""
                SELECT s.name, c.name
                FROM characters c
                JOIN series s ON s.id = c.series_id
                ORDER BY RANDOM()
                LIMIT 1
            """)
            row = await cur.fetchone()
            return (row[0], row[1]) if row else None

    # ---- meta ----
    async def next_serial(self) -> int:
        async with aiosqlite.connect(self.path) as db:
            cur = await db.execute("SELECT value FROM meta WHERE key='next_serial'")
            row = await cur.fetchone()
            n = int(row[0])
            await db.execute("UPDATE meta SET value=? WHERE key='next_serial'", (str(n+1),))
            await db.commit()
            return n

    async def get_meta(self, key: str) -> str | None:
        async with aiosqlite.connect(self.path) as db:
            cur = await db.execute("SELECT value FROM meta WHERE key=?", (key,))
            row = await cur.fetchone()
            return row[0] if row else None

    async def set_meta(self, key: str, value: str):
        async with aiosqlite.connect(self.path) as db:
            await db.execute("""
                INSERT INTO meta(key, value) VALUES(?, ?)
                ON CONFLICT(key) DO UPDATE SET value = excluded.value
            """, (key, value))
            await db.commit()

    def _autogen_weights(self, n: int, ratio: float = 1.6) -> list[int]:
        return [max(1, int(round(ratio ** i))) for i in range(n)]

    async def get_editions_config(self) -> tuple[int, list[int]]:
        n_default = 5
        w_default = self._autogen_weights(n_default)

        raw_n = await self.get_meta("editions_max")
        raw_w = await self.get_meta("edition_weights")

        try:
            n = int(raw_n) if raw_n is not None else n_default
        except Exception:
            n = n_default

        try:
            weights = json.loads(raw_w) if raw_w else w_default
            if not isinstance(weights, list) or not all(isinstance(x, (int, float)) for x in weights):
                raise ValueError
            weights = [int(max(1, round(float(x)))) for x in weights]
        except Exception:
            weights = w_default

        if len(weights) < n:
            extra_needed = n - len(weights)
            if weights:
                base = max(1, weights[-1])
                extra = []
                for i in range(extra_needed):
                    extra.append(max(1, int(round(base * (1.6 ** (i + 1))))))
                weights = weights + extra
            else:
                weights = self._autogen_weights(n)
        elif len(weights) > n:
            weights = weights[:n]

        return n, weights

    async def set_editions_config(self, n: int, weights: list[int] | None = None):
        if weights is None:
            weights = self._autogen_weights(n)
        weights = [int(max(1, w)) for w in weights]
        await self.set_meta("editions_max", str(int(n)))
        await self.set_meta("edition_weights", json.dumps(weights))

    # ---- users ----
    async def ensure_user(self, user_id: int):
        async with aiosqlite.connect(self.path) as db:
            await db.execute("""
                INSERT OR IGNORE INTO users(user_id, coins, gems, tickets)
                VALUES(?, 0, 0, 0)
            """, (user_id,))
            await db.commit()

    async def balance(self, user_id: int) -> int:
        async with aiosqlite.connect(self.path) as db:
            cur = await db.execute("SELECT coins FROM users WHERE user_id=?", (user_id,))
            row = await cur.fetchone()
            return int(row[0]) if row else 0

    async def get_items(self, user_id: int) -> dict:
        await self.ensure_user(user_id)
        async with aiosqlite.connect(self.path) as db:
            cur = await db.execute("""
                SELECT coins, gems, tickets,
                       dust_damaged, dust_poor, dust_good, dust_excellent, dust_mint
                FROM users WHERE user_id=?
            """, (user_id,))
            row = await cur.fetchone()
            if not row:
                return {"coins": 0, "gems": 0, "tickets": 0,
                        "dust_damaged": 0, "dust_poor": 0, "dust_good": 0, "dust_excellent": 0, "dust_mint": 0}
            coins, gems, tickets, dd, dp, dg, de, dm = row
            return {
                "coins": int(coins),
                "gems": int(gems),
                "tickets": int(tickets),
                "dust_damaged": int(dd),
                "dust_poor": int(dp),
                "dust_good": int(dg),
                "dust_excellent": int(de),
                "dust_mint": int(dm),
            }

    # ---- tags ----
    async def create_tag(self, user_id: int, name: str, emoji: str) -> bool:
        async with aiosqlite.connect(self.path) as db:
            try:
                await db.execute(
                    "INSERT INTO tags(user_id, name, emoji) VALUES(?,?,?)",
                    (str(user_id), name.lower(), emoji)
                )
                await db.commit()
                return True
            except Exception:
                return False

    async def delete_tag(self, user_id: int, name: str) -> bool:
        async with aiosqlite.connect(self.path) as db:
            cur = await db.execute(
                "SELECT id FROM tags WHERE user_id=? AND name=?",
                (str(user_id), name.lower())
            )
            row = await cur.fetchone()
            if not row:
                return False
            tag_id = row[0]
            await db.execute("DELETE FROM card_tags WHERE tag_id=?", (tag_id,))
            await db.execute("DELETE FROM tags WHERE id=?", (tag_id,))
            await db.commit()
            return True

    async def list_tags(self, user_id: int) -> list[dict]:
        async with aiosqlite.connect(self.path) as db:
            cur = await db.execute(
                "SELECT id, name, emoji FROM tags WHERE user_id=? ORDER BY name",
                (str(user_id),)
            )
            rows = await cur.fetchall()
            return [{"id": r[0], "name": r[1], "emoji": r[2]} for r in rows]

    async def assign_tag(self, user_id: int, card_uid: str, tag_name: str) -> bool:
        async with aiosqlite.connect(self.path) as db:
            cur = await db.execute(
                "SELECT id FROM tags WHERE user_id=? AND name=?",
                (str(user_id), tag_name.lower())
            )
            row = await cur.fetchone()
            if not row:
                return False
            tag_id = row[0]
            await db.execute(
                "INSERT OR REPLACE INTO card_tags(card_uid, tag_id) VALUES(?,?)",
                (card_uid, tag_id)
            )
            await db.commit()
            return True

    async def untag_card(self, card_uid: str):
        async with aiosqlite.connect(self.path) as db:
            await db.execute("DELETE FROM card_tags WHERE card_uid=?", (card_uid,))
            await db.commit()

    async def get_card_tag(self, card_uid: str) -> str:
        async with aiosqlite.connect(self.path) as db:
            cur = await db.execute(
                """SELECT t.emoji
                   FROM card_tags ct
                   JOIN tags t ON ct.tag_id = t.id
                   WHERE ct.card_uid=?""",
                (card_uid,)
            )
            row = await cur.fetchone()
            return row[0] if row else "◾"

    async def normalize_wishlist_rows(self):
        async with aiosqlite.connect(self.path) as db:
            await db.execute('UPDATE wishlists SET series=TRIM(series), "character"=TRIM("character")')
            await db.commit()

    # ---- cards ----
    async def set_character_image(self, series: str, character: str, set_id: int,
                              image_url: str, bytes_: int | None = None, mime: str | None = None):
        ts = datetime.now(timezone.utc).isoformat()
        async with aiosqlite.connect(self.path) as db:
            await db.execute("""
                INSERT INTO character_images(series, character, set_id, image_url, bytes, mime, updated_at)
                VALUES(?,?,?,?,?,?,?)
                ON CONFLICT(series, character, set_id)
                DO UPDATE SET image_url=excluded.image_url,
                            bytes=excluded.bytes,
                            mime=excluded.mime,
                            updated_at=excluded.updated_at
            """, (series, character, int(set_id), image_url, bytes_, mime, ts))
            await db.commit()

    async def get_character_image(self, series: str, character: str, set_id: int) -> str | None:
        async with aiosqlite.connect(self.path) as db:
            cur = await db.execute("""
                SELECT image_url FROM character_images
                WHERE series=? AND character=? AND set_id=?
            """, (series, character, int(set_id)))
            row = await cur.fetchone()
            return row[0] if row else None

    async def get_character_image_any(self, series: str, character: str) -> str | None:
        async with aiosqlite.connect(self.path) as db:
            cur = await db.execute("""
                SELECT image_url FROM character_images
                WHERE series=? AND character=?
                ORDER BY set_id ASC LIMIT 1
            """, (series, character))
            row = await cur.fetchone()
            return row[0] if row else None
    
    async def inventory_filtered(self, user_id: int, flt: dict):
        where = ["c.owned_by=?"]
        params = [str(user_id)]

        if s := flt.get("s"):
            where.append("LOWER(c.series) LIKE ?")
            params.append(f"%{s.lower()}%")

        if ch := flt.get("c"):
            where.append("LOWER(c.character) LIKE ?")
            params.append(f"%{ch.lower()}%")

        q_op = flt.get("q_op")
        q_val = flt.get("q_val")
        if q_op and q_val is not None:
            where.append(f"c.stars {q_op} ?")
            params.append(int(q_val))
        elif (q := flt.get("q")) is not None:
            where.append("c.stars = ?")
            params.append(int(q))

        if "t" in flt:
            t = flt["t"].strip().lower()
            if t == "none":
                where.append("ct.tag_id IS NULL")
            else:
                where.append("LOWER(t.name) = ?")
                params.append(t)

        if (e := flt.get("e")) is not None:
            where.append("c.set_id = ?")
            params.append(int(e))

        order = flt.get("o", "d")
        if order == "s":
            order_by = "c.series ASC, c.character ASC, c.set_id ASC, c.dropped_at DESC"
        else:
            order_by = "c.dropped_at DESC"

        sql = f"""
        SELECT
            c.card_uid,
            c.serial_number,
            c.stars,
            c.set_id,
            c.series,
            c.character,
            c.condition,
            COALESCE(t.emoji, '◾') AS tag_emoji
        FROM cards c
        LEFT JOIN card_tags ct ON ct.card_uid = c.card_uid
        LEFT JOIN tags t ON t.id = ct.tag_id
        WHERE {' AND '.join(where)}
        ORDER BY {order_by}
        """
        async with aiosqlite.connect(self.path) as db:
            cur = await db.execute(sql, params)
            return await cur.fetchall()

    async def insert_dropped_card(self, card: dict):
        series = card["series"]
        character = card["character"]
        set_id = int(card["set_id"])

        attempts = 0
        while True:
            attempts += 1
            serial_number = card.get("serial_number")
            if serial_number is None:
                serial_number = await self._random_free_serial(series, character, set_id)

            try:
                async with aiosqlite.connect(self.path) as db:
                    await db.execute("BEGIN IMMEDIATE")
                    await db.execute("""
                        INSERT INTO cards(
                            card_uid, serial_number, stars, set_id, series, character, condition,
                            dropped_at, dropped_in_server, dropped_by, grabbed_by, owned_by, grab_delay
                        )
                        VALUES(?,?,?,?,?,?,?,?,?,?,?,?,?)
                    """, (
                        card["card_uid"],
                        int(serial_number),
                        int(card["stars"]),
                        int(set_id),
                        series,
                        character,
                        card["condition"],
                        card["dropped_at"],
                        card["dropped_in_server"],
                        card["dropped_by"],
                        None, None, None
                    ))
                    await db.commit()
                return
            except aiosqlite.IntegrityError as e:
                if "uq_cards_series_character_set_serial" in str(e).lower():
                    card["serial_number"] = None
                    if attempts >= 20:
                        raise
                    continue
                else:
                    raise

    async def claim_card(self, card_uid: str, claimer_id: int, delay: float) -> bool:
        async with aiosqlite.connect(self.path) as db:
            cur = await db.execute("""
                UPDATE cards
                   SET grabbed_by=?, owned_by=?, grab_delay=?
                 WHERE card_uid=? AND grabbed_by IS NULL
            """, (str(claimer_id), str(claimer_id), delay, card_uid))
            await db.commit()
            return cur.rowcount == 1

    async def get_card(self, card_uid: str) -> dict | None:
        async with aiosqlite.connect(self.path) as db:
            cur = await db.execute("SELECT * FROM cards WHERE card_uid=?", (card_uid,))
            row = await cur.fetchone()
            if not row:
                return None
            cols = [c[0] for c in cur.description]
            return dict(zip(cols, row))

    async def inventory(self, user_id: int):
        async with aiosqlite.connect(self.path) as db:
            cur = await db.execute("""
            SELECT
                c.card_uid,
                c.serial_number,
                c.stars,
                c.set_id,
                c.series,
                c.character,
                c.condition,
                COALESCE(t.emoji, '◾') AS tag_emoji
            FROM cards c
            LEFT JOIN card_tags ct ON ct.card_uid = c.card_uid
            LEFT JOIN tags t ON t.id = ct.tag_id
            WHERE c.owned_by=?
            ORDER BY c.dropped_at DESC
            """, (str(user_id),))
            return await cur.fetchall()

    async def transfer(self, card_uid: str, from_id: int, to_id: int) -> bool:
        async with aiosqlite.connect(self.path) as db:
            cur = await db.execute("SELECT owned_by FROM cards WHERE card_uid=?", (card_uid,))
            row = await cur.fetchone()
            if not row or row[0] != str(from_id):
                return False
            await db.execute("UPDATE cards SET owned_by=? WHERE card_uid=?", (str(to_id), card_uid))
            await db.commit()
            return True

    async def burn(self, card_uid: str, owner_id: int) -> int | None:
        async with aiosqlite.connect(self.path) as db:
            cur = await db.execute("""
                SELECT owned_by, stars, set_id, series, character, grabbed_by, grab_delay
                FROM cards WHERE card_uid=?
            """, (card_uid,))
            row = await cur.fetchone()
            if not row or row[0] != str(owner_id):
                return None

            owned_by, stars, set_id, series, character, grabbed_by, grab_delay = row
            stars = int(stars)
            reward = BURN_REWARD_BY_STARS.get(stars, 0)

            from datetime import datetime, timezone
            burned_at = datetime.utcnow().replace(tzinfo=timezone.utc).isoformat()

            await db.execute("""
              INSERT OR REPLACE INTO burns(card_uid, series, character, stars, set_id, grabbed_by, grab_delay, owner_id, burned_at)
              VALUES(?,?,?,?,?,?,?,?,?)
            """, (card_uid, series, character, stars, set_id, grabbed_by, grab_delay, str(owner_id), burned_at))

            await db.execute("DELETE FROM cards WHERE card_uid=?", (card_uid,))

            quality = QUALITY_BY_STARS.get(stars, "damaged")
            dust_col = f"dust_{quality}"

            await db.execute("""
              INSERT INTO users(user_id, coins) VALUES(?, ?)
              ON CONFLICT(user_id) DO UPDATE SET coins = coins + excluded.coins
            """, (owner_id, reward))

            await db.execute(f"UPDATE users SET {dust_col} = {dust_col} + 1 WHERE user_id=?", (owner_id,))
            await db.commit()
            return reward

    async def character_stats(self, series: str, character: str, set_id: int | None = None) -> dict:
        canon = await self.find_canonical_series_character(series, character)
        if canon:
            series, character = canon

        params = [series, character]
        set_clause = ""
        if set_id is not None:
            set_clause = " AND set_id=?"
            params.append(set_id)

        async with aiosqlite.connect(self.path) as db:
            cur = await db.execute(f"""
                SELECT COUNT(*) AS total_current,
                    SUM(CASE WHEN grabbed_by IS NOT NULL THEN 1 ELSE 0 END) AS current_claimed,
                    AVG(CASE WHEN grab_delay IS NOT NULL THEN grab_delay END) AS current_avg_delay
                FROM cards
                WHERE series=? AND character=? {set_clause}
            """, params)
            current_total, current_claimed, current_avg_delay = await cur.fetchone() or (0, 0, None)
            current_total = int(current_total or 0)
            current_claimed = int(current_claimed or 0)
            current_avg_delay = float(current_avg_delay) if current_avg_delay is not None else None

            cur = await db.execute(f"""
                SELECT COUNT(*) AS burned_total,
                    SUM(CASE WHEN grabbed_by IS NOT NULL THEN 1 ELSE 0 END) AS burned_claimed,
                    AVG(CASE WHEN grab_delay IS NOT NULL THEN grab_delay END) AS burned_avg_delay
                FROM burns
                WHERE series=? AND character=? {set_clause}
            """, params)
            burned_total, burned_claimed, burned_avg_delay = await cur.fetchone() or (0, 0, None)
            burned_total = int(burned_total or 0)
            burned_claimed = int(burned_claimed or 0)
            burned_avg_delay = float(burned_avg_delay) if burned_avg_delay is not None else None

            cur = await db.execute(f"""
                SELECT stars, COUNT(*)
                FROM cards
                WHERE series=? AND character=? {set_clause} AND owned_by IS NOT NULL
                GROUP BY stars
            """, params)
            star_rows = await cur.fetchall()
            circ_by_stars = {int(s): int(c) for (s, c) in (star_rows or [])}

            cur = await db.execute("""
                SELECT COUNT(*)
                FROM wishlists w
                WHERE LOWER(REPLACE(REPLACE(REPLACE(TRIM(w.series), CHAR(160), ''), CHAR(8203), ''), ' ', ''))
                    = LOWER(REPLACE(REPLACE(REPLACE(TRIM(?),        CHAR(160), ''), CHAR(8203), ''), ' ', ''))
                AND LOWER(REPLACE(REPLACE(REPLACE(TRIM(w."character"), CHAR(160), ''), CHAR(8203), ''), ' ', ''))
                    = LOWER(REPLACE(REPLACE(REPLACE(TRIM(?),             CHAR(160), ''), CHAR(8203), ''), ' ', ''))
            """, (series, character))
            wishlisted = int((await cur.fetchone() or (0,))[0] or 0)

        total_generated = current_total + burned_total
        total_claimed   = current_claimed + burned_claimed
        claim_rate = (total_claimed / total_generated * 100.0) if total_generated else 0.0

        weighted = []
        if current_avg_delay is not None:
            weighted.append((current_avg_delay, current_claimed))
        if burned_avg_delay is not None:
            weighted.append((burned_avg_delay, burned_claimed))
        if weighted and sum(w for _, w in weighted):
            avg_delay = sum(a * w for a, w in weighted) / sum(w for _, w in weighted)
        else:
            avg_delay = None

        n_editions, _weights = await self.get_editions_config()
        editions = list(range(1, int(n_editions) + 1))

        return {
            "series": series,
            "character": character,
            "set_id": set_id,
            "editions": editions,
            "total_generated": total_generated,
            "total_claimed": total_claimed,
            "total_burned": burned_total,
            "total_in_circulation": current_total,
            "claim_rate": claim_rate,
            "avg_claim_time": avg_delay,
            "circ_by_stars": {
                4: circ_by_stars.get(4, 0),
                3: circ_by_stars.get(3, 0),
                2: circ_by_stars.get(2, 0),
                1: circ_by_stars.get(1, 0),
                0: circ_by_stars.get(0, 0),
            },
            "wishlisted": wishlisted,
        }

    async def get_latest_card(self, user_id: int) -> dict | None:
        async with aiosqlite.connect(self.path) as db:
            cur = await db.execute("""
                SELECT * FROM cards
                WHERE owned_by=?
                ORDER BY dropped_at DESC
                LIMIT 1
            """, (str(user_id),))
            row = await cur.fetchone()
            if not row:
                return None
            cols = [c[0] for c in cur.description]
            return dict(zip(cols, row))

    # ---------- transactional upgrade ----------
    async def perform_upgrade(
        self,
        user_id: int,
        card_uid: str,
        gold_cost: int,
        dust_quality: str,
        dust_cost: int,
        new_stars: int,
    ) -> bool:
        dust_col = f"dust_{dust_quality}"
        new_condition = QUALITY_BY_STARS.get(int(new_stars), "damaged")

        async with aiosqlite.connect(self.path) as db:
            try:
                await db.execute("BEGIN IMMEDIATE")

                cur = await db.execute("SELECT owned_by, stars FROM cards WHERE card_uid=?", (card_uid,))
                row = await cur.fetchone()
                if not row or row[0] != str(user_id):
                    await db.execute("ROLLBACK")
                    return False

                cur = await db.execute(
                    f"SELECT coins, {dust_col} FROM users WHERE user_id=?",
                    (user_id,)
                )
                urow = await cur.fetchone()
                if not urow:
                    await db.execute("ROLLBACK")
                    return False
                coins, dust_qty = int(urow[0]), int(urow[1])
                if coins < gold_cost or dust_qty < dust_cost:
                    await db.execute("ROLLBACK")
                    return False

                await db.execute(
                    f"UPDATE users SET coins = coins - ?, {dust_col} = {dust_col} - ? WHERE user_id=?",
                    (int(gold_cost), int(dust_cost), user_id)
                )
                await db.execute(
                    "UPDATE cards SET stars=?, condition=? WHERE card_uid=?",
                    (int(new_stars), new_condition, card_uid)
                )

                await db.commit()
                return True
            except Exception:
                await db.execute("ROLLBACK")
                return False


# ===== menami\embeds.py =====

import discord
from .helpers import stars_to_str, iso_utc_to_text
from .config import QUALITY_BY_STARS, BURN_REWARD_BY_STARS, UPGRADE_RULES

# ========= Card detail & drops =========

def format_card_embed(card: dict, claimed: bool):
    ts_text = iso_utc_to_text(card["dropped_at"])
    owner = f"<@{card['owned_by']}>" if card["owned_by"] else "—"
    grabbed = f"<@{card['grabbed_by']}>" if card["grabbed_by"] else "—"
    dropped_by = f"<@{card['dropped_by']}>"
    stars_str = stars_to_str(int(card["stars"]))

    uid_box    = f"`{card['card_uid']}`"
    stars_box  = f"`{stars_str}`"
    serial_box = f"`#{card['serial_number']}`"
    setid_box  = f"`◈{card['set_id']}`"
    server_box = f"`{card['dropped_in_server']}`"

    title = f"{uid_box} · {stars_box} · {serial_box} · {setid_box} · {card['series']} · **{card['character']}**"

    desc_lines = [
        f"Dropped on **{ts_text}**",
        f"Dropped in server ID {server_box}",
        "",
        f"Owned by {owner}",
        f"Grabbed by {grabbed}",
        f"Dropped by {dropped_by}",
        "",
        f"Dropped in **{card['condition']}** condition",
    ]
    if card["grab_delay"] is not None:
        try:
            desc_lines.append(f"Grabbed after **{float(card['grab_delay']):.2f} seconds**")
        except Exception:
            pass

    embed = discord.Embed(
        title="Card Details",
        description="\n".join([title, "", *desc_lines]),
        color=discord.Color.gold()
    )
    if claimed and card["grab_delay"] is None:
        embed.set_footer(text="Claim processed.")
    return embed

def build_triple_drop_embed(cards: list[dict]):
    from .config import EMOJIS, CLAIM_WINDOW_S
    lines = []
    for idx, c in enumerate(cards, start=1):
        stars_str = stars_to_str(int(c["stars"]))
        lines.append(f"{EMOJIS[idx-1]}  {c['card_uid']} · {stars_str} · #{c['serial_number']} · ◈{c['set_id']} · {c['series']} · {c['character']}")
    desc = "**React to claim one card**\n" f"Claim window: {CLAIM_WINDOW_S}s\n\n" + "\n".join(lines)
    return discord.Embed(title="Card Drop — pick with reactions", description=desc, color=discord.Color.blurple())

def build_simple_cardinfo_embed(card: dict) -> discord.Embed:
    stars_str = stars_to_str(int(card["stars"]))
    owner_id = card.get("owned_by")
    owner = f"<@{owner_id}>" if owner_id else "Unowned"

    line = (
        f"{card['card_uid']} · {stars_str} · "
        f"#{card['serial_number']} · ◈{card['set_id']} · "
        f"{card['series']} · {card['character']}"
    )

    e = discord.Embed(title="Card Details", color=discord.Color.blurple())
    e.description = f"Owned by {owner}\n\n{line}"
    return e

def build_character_lookup_embed(stats: dict, edition_index: int) -> discord.Embed:
    e = discord.Embed(title="Character Lookup", color=discord.Color.blurple())
    avg = f"{stats['avg_claim_time']:.1f} seconds" if stats["avg_claim_time"] is not None else "N/A"
    e.description = (
        f"Character · {stats['character']}\n"
        f"Series · {stats['series']}\n"
        f"Wishlisted · {stats['wishlisted']:,}\n\n"
        f"Total generated · {stats['total_generated']:,}\n"
        f"Total claimed · {stats['total_claimed']:,}\n"
        f"Total burned · {stats['total_burned']:,}\n"
        f"Total in circulation · {stats['total_in_circulation']:,}\n"
        f"Claim rate · {stats['claim_rate']:.0f}%\n"
        f"Average claim time · {avg}\n\n"
        f"Circulation (★★★★) · {stats['circ_by_stars'][4]:,}\n"
        f"Circulation (★★★☆) · {stats['circ_by_stars'][3]:,}\n"
        f"Circulation (★★☆☆) · {stats['circ_by_stars'][2]:,}\n"
        f"Circulation (★☆☆☆) · {stats['circ_by_stars'][1]:,}\n"
        f"Circulation (☆☆☆☆) · {stats['circ_by_stars'][0]:,}\n"
    )
    total_editions = max(len(stats["editions"]), 1)
    set_id = stats.get("set_id")
    if set_id is None:
        e.set_footer(text=f"All editions • {edition_index}/{total_editions}")
    else:
        e.set_footer(text=f"Edition ◈{set_id} • {edition_index}/{total_editions}")
    return e

# ========= Burn embeds =========

def build_burn_preview_embed(requester: discord.abc.User, stars: int) -> discord.Embed:
    coins = BURN_REWARD_BY_STARS.get(stars, 0)
    dust = f"1 Dust ({stars_to_str(stars)})"
    gold = f"{coins} Coins"
    desc = f"{requester.mention}, you will receive:\n\n{gold}\n{dust}"
    return discord.Embed(title="Burn Card", description=desc, color=discord.Color.dark_grey())

def build_burn_result_embed(base: discord.Embed, text: str, color: discord.Color) -> discord.Embed:
    e = discord.Embed(title=base.title, description=base.description + f"\n\n{text}", color=color)
    return e

# ========= Upgrade embeds =========

def _upgrade_rule_for(stars: int):
    return UPGRADE_RULES.get(int(stars))

def build_upgrade_preview_embed(user: discord.abc.User, card: dict) -> discord.Embed:
    curr = int(card["stars"])
    rule = _upgrade_rule_for(curr)
    e = discord.Embed(title="Card Upgrade", color=discord.Color.orange())
    if rule is None:
        e.description = (
            "The upgrade succeeded! The card has been upgraded to **mint** condition.\n\n"
            f"{user.mention}, you have reached the highest condition for this card."
        )
        return e

    to = rule["to"]
    chance = int(round(rule["chance"] * 100))
    gold = rule["gold"]
    dust = rule["dust"]
    dust_label = f"- {dust} Dust ({stars_to_str(to)})"
    gold_label = f"- {gold} Gold"

    fail_text = "will not change" if rule["fail"] == "stay" else "will fall to **damaged**"
    e.description = (
        f"{user.mention}, upgrading the condition of `{card['card_uid']}` "
        f"from **{QUALITY_BY_STARS[curr]}** to **{QUALITY_BY_STARS[to]}** has a **{chance}%** chance of succeeding. "
        f"If this upgrade fails, the card's condition {fail_text}.\n\n"
        "Attempting the upgrade will cost the following resources:\n"
        f"-{dust_label}\n"
        f"-{gold_label}\n\n"
        "Use the 🔨 button to attempt the upgrade."
    )
    return e

def build_upgrade_outcome_embed(base: discord.Embed, success: bool, new_stars: int) -> discord.Embed:
    if success:
        text = f"The upgrade succeeded! The card has been upgraded to **{QUALITY_BY_STARS[new_stars]}** condition."
        return discord.Embed(title=base.title, description=text, color=discord.Color.green())
    else:
        text = f"The upgrade failed. The card is now **{QUALITY_BY_STARS[new_stars]}**."
        return discord.Embed(title=base.title, description=text, color=discord.Color.red())


# ===== menami\helpers.py =====

import os
import random
import string
from datetime import datetime, timezone
from .config import STAR_MIN, STAR_MAX, QUALITY_BY_STARS, STAR_WEIGHTS

def gen_card_uid() -> str:
    return "".join(random.choices(string.ascii_lowercase + string.digits, k=7))

def stars_to_str(n: int) -> str:
    n = max(0, min(4, int(n)))
    return "★" * n + "☆" * (4 - n)

def iso_utc_to_text(iso_str: str) -> str:
    dt = datetime.fromisoformat(iso_str)
    if dt.tzinfo is None:
        dt = dt.replace(tzinfo=timezone.utc)
    if os.name == "nt":
        return dt.strftime("%B %#d, %Y %#I:%M %p")
    return dt.strftime("%B %-d, %Y %-I:%M %p")

async def choose_edition(db) -> int:
    n, weights = await db.get_editions_config()
    editions = list(range(1, n + 1))
    return random.choices(editions, weights=weights, k=1)[0]

async def make_single_card_payload(db, invoker_id: int, guild_id: int) -> dict:
    from .config import STAR_MIN, STAR_MAX, STAR_WEIGHTS, QUALITY_BY_STARS
    set_id = await choose_edition(db)
    sc = await db.random_series_character()
    if not sc:
        series, character = ("Unknown Series", "Unknown Character")
    else:
        series, character = sc

    domain = list(range(STAR_MIN, STAR_MAX + 1))
    try:
        if len(STAR_WEIGHTS) != len(domain) or any(float(w) <= 0 for w in STAR_WEIGHTS):
            raise ValueError
        stars = int(random.choices(domain, weights=STAR_WEIGHTS, k=1)[0])
    except Exception:
        stars = int(random.randint(STAR_MIN, STAR_MAX))

    condition = QUALITY_BY_STARS.get(int(stars), "damaged")
    dropped_at = datetime.now(timezone.utc).isoformat()
    return {
        "card_uid": gen_card_uid(),
        "serial_number": None,
        "stars": stars,
        "set_id": set_id,
        "series": series,
        "character": character,
        "condition": condition,
        "dropped_at": dropped_at,
        "dropped_in_server": str(guild_id),
        "dropped_by": str(invoker_id),
    }


# ===== menami\views.py =====

from __future__ import annotations
from typing import List, Tuple
import math
import random
import discord
from discord.ext import commands
import io

from .card_render import render_card_image

from .embeds import (
    build_burn_result_embed,
    build_upgrade_preview_embed,
    build_upgrade_outcome_embed,
    build_character_lookup_embed,
)

from .config import UPGRADE_RULES, QUALITY_BY_STARS
from .helpers import stars_to_str

PAGE_SIZE_ITEMS = 10
PAGE_SIZE_COLLECTION = 10


def page_range_text(page: int, total: int, page_size: int, noun: str) -> str:
    if total == 0:
        return f"Showing {noun} 0–0 of 0"
    start = page * page_size + 1
    end = min((page + 1) * page_size, total)
    return f"Showing {noun} {start}–{end} of {total}"


def slice_page(items: List[str], page: int, page_size: int) -> List[str]:
    start = page * page_size
    end = start + page_size
    return items[start:end]


def format_inventory_header(user: discord.abc.User) -> str:
    return "## Inventory\n" f"Items carried by {user.mention}\n\n"


def format_items_page(items: List[str]) -> str:
    if not items:
        return ""
    return "\n".join(items) + "\n"


def format_collection_page(rows: list[tuple], page: int, page_size: int) -> str:
    start = page * page_size
    end = start + page_size
    page_rows = rows[start:end]

    if not page_rows:
        return "_No cards to show._"

    lines = []
    for r in page_rows:
        uid, serial, stars, set_id, series, character, _condition, tag_emoji = r

        stars_str = stars_to_str(int(stars))
        uid_box = f"`{uid}`"
        stars_box = f"`{stars_str}`"
        serial_box = f"`#{serial}`"
        setid_box = f"`◈{set_id}`"

        lines.append(
            f"{tag_emoji} {uid_box} · {stars_box} · {serial_box} · {setid_box} · {series} · **{character}**"
        )

    return "\n".join(lines)


def balances_to_items(bal: dict) -> List[str]:
    base = [
        f":coin: **{bal['coins']:,}** · `coin` · *Coin*",
        f":gem: **{bal['gems']:,}** · `gem` · *Gem*",
        f"🎟️ **{bal['tickets']:,}** · `ticket` · *Ticket*",
    ]
    dust_specs = [
        ("✨", bal.get("dust_mint", 0), "dust_mint", "mint", 4),
        ("✨", bal.get("dust_excellent", 0), "dust_excellent", "excellent", 3),
        ("✨", bal.get("dust_good", 0), "dust_good", "good", 2),
        ("✨", bal.get("dust_poor", 0), "dust_poor", "poor", 1),
        ("✨", bal.get("dust_damaged", 0), "dust_damaged", "damaged", 0),
    ]
    dust_lines = [
        f"{icon} **{qty:,}** · `{key}` · *Dust ({stars_to_str(stars)})*"
        for icon, qty, key, _label, stars in dust_specs
        if qty > 0
    ]
    return base + dust_lines


class InventoryView(discord.ui.View):
    def __init__(self, bot: commands.Bot, target: discord.abc.User, items: List[str], *, ephemeral: bool = False):
        super().__init__(timeout=120)
        self.bot = bot
        self.target = target
        self.items_all = items
        self.page = 0
        self.page_size = PAGE_SIZE_ITEMS
        self.pages = math.ceil(len(items) / self.page_size) if items else 1
        self.ephemeral = ephemeral
        if self.pages <= 1:
            self.clear_items()
        else:
            self._update_buttons()

    def _update_buttons(self):
        disable_prev = self.page <= 0
        disable_next = self.page >= self.pages - 1
        for child in self.children:
            if isinstance(child, discord.ui.Button):
                if child.custom_id in {"first_i", "prev_i"}:
                    child.disabled = disable_prev
                elif child.custom_id in {"next_i", "last_i"}:
                    child.disabled = disable_next

    def build_embed(self) -> discord.Embed:
        embed = discord.Embed(color=discord.Color.blurple())
        embed.description = format_inventory_header(self.target)
        total = len(self.items_all)
        if total > 0:
            current_items = slice_page(self.items_all, self.page, self.page_size)
            embed.description += format_items_page(current_items)
            embed.set_footer(text=page_range_text(self.page, total, self.page_size, "items"))
        return embed

    async def refresh(self, interaction: discord.Interaction):
        if self.pages > 1:
            self._update_buttons()
        await interaction.response.edit_message(embed=self.build_embed(), view=self)

    @discord.ui.button(emoji="⏮️", style=discord.ButtonStyle.secondary, custom_id="first_i")
    async def first(self, interaction: discord.Interaction, button: discord.ui.Button):
        self.page = 0
        await self.refresh(interaction)

    @discord.ui.button(emoji="◀️", style=discord.ButtonStyle.secondary, custom_id="prev_i")
    async def prev(self, interaction: discord.Interaction, button: discord.ui.Button):
        if self.page > 0:
            self.page -= 1
        await self.refresh(interaction)

    @discord.ui.button(emoji="▶️", style=discord.ButtonStyle.secondary, custom_id="next_i")
    async def next(self, interaction: discord.Interaction, button: discord.ui.Button):
        if self.page < self.pages - 1:
            self.page += 1
        await self.refresh(interaction)

    @discord.ui.button(emoji="⏭️", style=discord.ButtonStyle.secondary, custom_id="last_i")
    async def last(self, interaction: discord.Interaction, button: discord.ui.Button):
        self.page = self.pages - 1
        await self.refresh(interaction)


class CollectionView(discord.ui.View):
    def __init__(self, bot: commands.Bot, target: discord.abc.User, rows: List[Tuple], *, ephemeral: bool = False):
        super().__init__(timeout=120)
        self.bot = bot
        self.target = target
        self.rows = rows
        self.page = 0
        self.page_size = PAGE_SIZE_COLLECTION
        self.pages = math.ceil(len(rows) / self.page_size) if rows else 1
        self.ephemeral = ephemeral
        if self.pages <= 1:
            self.clear_items()
        else:
            self._update_buttons()

    def _update_buttons(self):
        disable_prev = self.page <= 0
        disable_next = self.page >= self.pages - 1
        for child in self.children:
            if isinstance(child, discord.ui.Button):
                if child.custom_id in {"first_c", "prev_c"}:
                    child.disabled = disable_prev
                elif child.custom_id in {"next_c", "last_c"}:
                    child.disabled = disable_next

    def build_embed(self) -> discord.Embed:
        embed = discord.Embed(color=discord.Color.blurple())
        embed.description = f"## Card Collection\nCards owned by {self.target.mention}\n\n"
        embed.description += format_collection_page(self.rows, self.page, self.page_size)
        embed.set_footer(text=page_range_text(self.page, len(self.rows), self.page_size, "cards"))
        return embed

    async def refresh(self, interaction: discord.Interaction):
        if self.pages > 1:
            self._update_buttons()
        await interaction.response.edit_message(embed=self.build_embed(), view=self)

    @discord.ui.button(emoji="⏮️", style=discord.ButtonStyle.secondary, custom_id="first_c")
    async def first(self, interaction: discord.Interaction, button: discord.ui.Button):
        self.page = 0
        await self.refresh(interaction)

    @discord.ui.button(emoji="◀️", style=discord.ButtonStyle.secondary, custom_id="prev_c")
    async def prev(self, interaction: discord.Interaction, button: discord.ui.Button):
        if self.page > 0:
            self.page -= 1
        await self.refresh(interaction)

    @discord.ui.button(emoji="▶️", style=discord.ButtonStyle.secondary, custom_id="next_c")
    async def next(self, interaction: discord.Interaction, button: discord.ui.Button):
        if self.page < self.pages - 1:
            self.page += 1
        await self.refresh(interaction)

    @discord.ui.button(emoji="⏭️", style=discord.ButtonStyle.secondary, custom_id="last_c")
    async def last(self, interaction: discord.Interaction, button: discord.ui.Button):
        self.page = self.pages - 1
        await self.refresh(interaction)


class ConfirmBurnView(discord.ui.View):
    def __init__(self, bot: commands.Bot, requester_id: int, card_uid: str, stars: int):
        super().__init__(timeout=30)
        self.bot = bot
        self.requester_id = requester_id
        self.card_uid = card_uid
        self.stars = stars
        self._done = False
        self.message: discord.Message | None = None

    async def interaction_guard(self, interaction: discord.Interaction) -> bool:
        if interaction.user.id != self.requester_id:
            await interaction.response.send_message("Only the requester can use these buttons.", ephemeral=True)
            return False
        return True

    async def finalize(self, interaction: discord.Interaction, embed: discord.Embed, color: discord.Color, text: str):
        self._done = True
        for c in self.children:
            if isinstance(c, discord.ui.Button):
                c.disabled = True
        await interaction.response.edit_message(embed=build_burn_result_embed(embed, text, color), view=self)

    @discord.ui.button(emoji="❌", style=discord.ButtonStyle.secondary, custom_id="burn_cancel")
    async def cancel(self, interaction: discord.Interaction, button: discord.ui.Button):
        if not await self.interaction_guard(interaction):
            return
        await self.finalize(interaction, interaction.message.embeds[0], discord.Color.red(), "Card burning has been canceled.")

    @discord.ui.button(emoji="🔥", style=discord.ButtonStyle.secondary, custom_id="burn_confirm")
    async def confirm(self, interaction: discord.Interaction, button: discord.ui.Button):
        if not await self.interaction_guard(interaction):
            return

        card = await self.bot.db.get_card(self.card_uid)
        if not card or card.get("owned_by") != str(self.requester_id):
            await self.finalize(interaction, interaction.message.embeds[0], discord.Color.red(), "You don't own that card or it doesn't exist.")
            return

        reward = await self.bot.db.burn(self.card_uid, self.requester_id)
        if reward is None:
            await self.finalize(interaction, interaction.message.embeds[0], discord.Color.red(), "You don't own that card or it doesn't exist.")
            return

        base = interaction.message.embeds[0] if interaction.message.embeds else discord.Embed(title="Burn Card")
        result = build_burn_result_embed(base, "The card has been burned.", discord.Color.green())

        self._done = True
        for c in self.children:
            if isinstance(c, discord.ui.Button):
                c.disabled = True

        await interaction.response.edit_message(embed=result, view=self)

    async def on_timeout(self):
        if self._done or not self.message:
            return
        for c in self.children:
            if isinstance(c, discord.ui.Button):
                c.disabled = True
        base = self.message.embeds[0] if self.message.embeds else discord.Embed(title="Burn Card", color=discord.Color.dark_grey())
        timed = build_burn_result_embed(base, "Card burning timed out.", discord.Color.red())
        try:
            await self.message.edit(embed=timed, view=self)
        except Exception:
            pass


class EditionLookupView(discord.ui.View):
    def __init__(
        self,
        bot: commands.Bot,
        series: str,
        character: str,
        editions: list[int],
        start_index: int = 0,
        requester_id: int | None = None,
        wrap: bool = False,
    ):
        super().__init__(timeout=120)
        self.bot = bot
        self.series = series
        self.character = character
        self.editions = list(editions or [])
        self.index = max(0, min(start_index, max(len(self.editions) - 1, 0)))
        self.requester_id = requester_id
        self.wrap = wrap
        self.message: discord.Message | None = None
        if len(self.editions) <= 1:
            self.clear_items()

    async def _fetch_stats(self, set_id: int | None):
        return await self.bot.db.character_stats(self.series, self.character, set_id=set_id)

    async def build_embed(self) -> discord.Embed:
        set_id = self.editions[self.index]
        stats = await self._fetch_stats(set_id)
        embed = build_character_lookup_embed(stats, self.index + 1)

        img_url = await self.bot.db.get_character_image(self.series, self.character, set_id)
        if not img_url:
            img_url = await self.bot.db.get_character_image_any(self.series, self.character)

        if img_url:
            embed.set_thumbnail(url=img_url)

        return embed

    def _update_buttons(self):
        if not self.editions or self.wrap:
            return
        disable_prev = self.index <= 0
        disable_next = self.index >= len(self.editions) - 1
        for child in self.children:
            if isinstance(child, discord.ui.Button):
                if child.custom_id == "ed_prev":
                    child.disabled = disable_prev
                elif child.custom_id == "ed_next":
                    child.disabled = disable_next

    async def _guard(self, interaction: discord.Interaction) -> bool:
        if self.requester_id and interaction.user.id != self.requester_id:
            await interaction.response.send_message("Only the requester can use these buttons.", ephemeral=True)
            return False
        return True

    async def refresh(self, interaction: discord.Interaction):
        self._update_buttons()
        embed = await self.build_embed()
        await interaction.response.edit_message(embed=embed, view=self)

    @discord.ui.button(emoji="◀️", style=discord.ButtonStyle.secondary, custom_id="ed_prev")
    async def prev(self, interaction: discord.Interaction, button: discord.ui.Button):
        if not await self._guard(interaction):
            return
        if not self.editions:
            return
        if self.index > 0:
            self.index -= 1
        elif self.wrap:
            self.index = len(self.editions) - 1
        await self.refresh(interaction)

    @discord.ui.button(emoji="▶️", style=discord.ButtonStyle.secondary, custom_id="ed_next")
    async def next(self, interaction: discord.Interaction, button: discord.ui.Button):
        if not await self._guard(interaction):
            return
        if not self.editions:
            return
        if self.index < len(self.editions) - 1:
            self.index += 1
        elif self.wrap:
            self.index = 0
        await self.refresh(interaction)

    async def on_timeout(self):
        for c in self.children:
            if isinstance(c, discord.ui.Button):
                c.disabled = True
        try:
            embed = await self.build_embed()
            if self.message:
                await self.message.edit(embed=embed, view=self)
        except Exception:
            pass

# ===================== UPGRADE =====================

class UpgradeView(discord.ui.View):
    def __init__(self, bot: commands.Bot, requester_id: int, card_uid: str):
        super().__init__(timeout=60)
        self.bot = bot
        self.requester_id = requester_id
        self.card_uid = card_uid
        self.message: discord.Message | None = None

    async def _fetch_card(self):
        return await self.bot.db.get_card(self.card_uid)

    async def _ensure_owner(self, interaction: discord.Interaction) -> bool:
        if interaction.user.id != self.requester_id:
            await interaction.response.send_message("Only the requester can use these buttons.", ephemeral=True)
            return False
        return True

    @discord.ui.button(emoji="🔨", style=discord.ButtonStyle.secondary, custom_id="upgrade_hammer")
    async def hammer(self, interaction: discord.Interaction, button: discord.ui.Button):
        if not await self._ensure_owner(interaction):
            return

        card = await self._fetch_card()
        if not card:
            await interaction.response.edit_message(content="Card not found.", embed=None, view=None)
            return
        if str(interaction.user.id) != card.get("owned_by"):
            await interaction.response.send_message("You don't own this card.", ephemeral=True)
            return

        curr = int(card["stars"])
        rule = UPGRADE_RULES.get(curr)
        if rule is None:
            preview = build_upgrade_preview_embed(interaction.user, card)
            await interaction.response.edit_message(embed=preview, view=None)
            return

        items = await self.bot.db.get_items(interaction.user.id)
        gold_cost = int(rule["gold"])
        dust_cost = int(rule["dust"])
        target_stars = int(rule["to"])
        dust_quality = QUALITY_BY_STARS.get(target_stars, "damaged")
        dust_col = f"dust_{dust_quality}"

        if items.get("coins", 0) < gold_cost or items.get(dust_col, 0) < dust_cost:
            missing = []
            if items.get("coins", 0) < gold_cost:
                missing.append(f"💰 {gold_cost - items.get('coins', 0)} Gold")
            if items.get(dust_col, 0) < dust_cost:
                missing.append(f"✨ {dust_cost - items.get(dust_col, 0)} Dust ({stars_to_str(target_stars)})")
            await interaction.response.send_message("Not enough resources: " + ", ".join(missing), ephemeral=True)
            return

        success = random.random() < float(rule["chance"])
        fail_to = 0 if rule["fail"] == "damaged" else curr
        new_stars = target_stars if success else fail_to

        ok = await self.bot.db.perform_upgrade(
            user_id=interaction.user.id,
            card_uid=self.card_uid,
            gold_cost=gold_cost,
            dust_quality=dust_quality,
            dust_cost=dust_cost,
            new_stars=new_stars,
        )
        if not ok:
            await interaction.response.send_message("Upgrade could not be applied (state changed?). Try again.", ephemeral=True)
            return

        outcome = build_upgrade_outcome_embed(discord.Embed(title="Card Upgrade"), success, new_stars)
        await interaction.response.edit_message(embed=outcome, view=None)

        updated = await self._fetch_card()
        preview_next = build_upgrade_preview_embed(interaction.user, updated)
        if UPGRADE_RULES.get(int(updated["stars"])) is not None:
            new_view = UpgradeView(self.bot, self.requester_id, self.card_uid)
            msg = await interaction.followup.send(embed=preview_next, view=new_view)
            new_view.message = msg
        else:
            await interaction.followup.send(embed=preview_next)

    @discord.ui.button(emoji="❌", style=discord.ButtonStyle.secondary, custom_id="upgrade_cancel")
    async def cancel(self, interaction: discord.Interaction, button: discord.ui.Button):
        if not await self._ensure_owner(interaction):
            return
        e = discord.Embed(
            title="Card Upgrade",
            description=f"{interaction.user.mention} cancelled the upgrade.",
            color=discord.Color.dark_grey(),
        )
        await interaction.response.edit_message(embed=e, view=None)

    async def on_timeout(self):
        if not self.message:
            return
        for c in self.children:
            if isinstance(c, discord.ui.Button):
                c.disabled = True
        try:
            await self.message.edit(view=self)
        except Exception:
            pass


# ===== menami\cogs\__init__.py =====

# empty ok


# ===== menami\cogs\cooldowns.py =====

from __future__ import annotations
import random
import time
import discord
from discord import app_commands
from discord.ext import commands

from ..config import (
    DROP_COOLDOWN_S,
    USER_DROP_COOLDOWN_S,
    GRAB_COOLDOWN_S,
    DAILY_COOLDOWN_S,
    DAILY_COINS_MIN, DAILY_COINS_MAX,
    DAILY_GEMS_MIN,  DAILY_GEMS_MAX,
)

def fmt_secs(n: int) -> str:
    if n <= 0:
        return "ready"
    h = n // 3600
    m = (n % 3600) // 60
    s = n % 60
    if h: return f"{h}h {m}m {s}s"
    if m: return f"{m}m {s}s"
    return f"{s}s"

class CooldownsCog(commands.Cog):
    def __init__(self, bot: commands.Bot):
        self.bot = bot

    @app_commands.command(name="cooldowns", description="Show your personal cooldowns (drop, grab, daily).")
    async def slash_cooldowns(self, interaction: discord.Interaction):
        embed = await self._build_embed(interaction.user, interaction.guild_id, interaction.channel_id)
        await interaction.response.send_message(embed=embed, ephemeral=True)

    @commands.command(name="cooldowns", aliases=["cd", "mcd"])
    async def cmd_cooldowns(self, ctx: commands.Context):
        e = await self._build_embed(ctx.author, ctx.guild.id if ctx.guild else None, ctx.channel.id)
        await ctx.send(embed=e)

    async def _build_embed(self, user: discord.abc.User, guild_id: int | None, channel_id: int | None) -> discord.Embed:
        drop_left  = await self.bot.db.seconds_remaining(user.id, "drop", USER_DROP_COOLDOWN_S)
        grab_left  = await self.bot.db.seconds_remaining(user.id, "grab", GRAB_COOLDOWN_S)
        daily_left = await self.bot.db.seconds_remaining(user.id, "daily", DAILY_COOLDOWN_S)

        channel_left = None
        if guild_id and channel_id:
            cd = DROP_COOLDOWN_S
            try:
                v = await self.bot.db.get_drop_cooldown(guild_id)
                if v is not None:
                    cd = v
            except Exception:
                pass
            last = self.bot.channel_cooldowns.get(channel_id, 0)
            remain = int(max(0, cd - (time.time() - last)))
            if remain > 0:
                channel_left = remain

        desc = [
            f"**Drop**  · {fmt_secs(drop_left)}",
            f"**Grab**  · {fmt_secs(grab_left)}",
            f"**Daily** · {fmt_secs(daily_left)}",
        ]
        if channel_left is not None:
            desc.append(f"_Channel lock_ · {fmt_secs(channel_left)}")

        e = discord.Embed(title="Your Cooldowns", description="\n".join(desc), color=discord.Color.blurple())
        e.set_footer(text="Personal timers. Channel lock = server’s per-channel drop cooldown.")
        return e

    @app_commands.command(name="daily", description="Collect your daily reward (coins & gems).")
    async def slash_daily(self, interaction: discord.Interaction):
        e = await self._do_daily(interaction.user.id)
        await interaction.response.send_message(embed=e, ephemeral=True)

    @commands.command(name="daily", aliases=["mdaily"])
    async def cmd_daily(self, ctx: commands.Context):
        e = await self._do_daily(ctx.author.id)
        await ctx.send(embed=e)

    async def _do_daily(self, user_id: int) -> discord.Embed:
        left = await self.bot.db.seconds_remaining(user_id, "daily", DAILY_COOLDOWN_S)
        if left > 0:
            return discord.Embed(
                title="Daily Reward",
                description=f"⏳ You already collected your daily. Come back in **{fmt_secs(left)}**.",
                color=discord.Color.orange(),
            )

        coins = random.randint(DAILY_COINS_MIN, DAILY_COINS_MAX)
        gems  = random.randint(DAILY_GEMS_MIN,  DAILY_GEMS_MAX)
        await self.bot.db.add_currency(user_id, coins=coins, gems=gems)
        await self.bot.db.set_timer(user_id, "daily")

        return discord.Embed(
            title="Daily Reward",
            description=f"🎉 You received **{coins} Coins** and **{gems} Gems**!",
            color=discord.Color.green(),
        )

async def setup(bot: commands.Bot):
    await bot.add_cog(CooldownsCog(bot))


# ===== menami\cogs\drops.py =====

from __future__ import annotations
import time
import asyncio
import discord
import io
from discord import app_commands
from discord.ext import commands
from ..card_render import render_drop_triptych

from ..config import DROP_COOLDOWN_S, CLAIM_WINDOW_S, EMOJIS
from ..helpers import make_single_card_payload

class DropsCog(commands.Cog):
    def __init__(self, bot: commands.Bot):
        self.bot: commands.Bot = bot

    async def _get_active_drop_channel(self, guild_id: int) -> int | None:
        return await self.bot.db.get_drop_channel(guild_id)

    async def _cooldown_for(self, guild_id: int) -> int:
        v = await self.bot.db.get_drop_cooldown(guild_id)
        return v if v is not None else DROP_COOLDOWN_S

    async def create_three_cards(self, invoker_id: int, guild_id: int):
        cards = []
        for _ in range(3):
            payload = await make_single_card_payload(self.bot.db, invoker_id, guild_id)
            await self.bot.db.insert_dropped_card(payload)
            saved = await self.bot.db.get_card(payload["card_uid"])
            cards.append(saved or payload)
        return cards

    async def add_number_reactions(self, message: discord.Message):
        for e in EMOJIS:
            try:
                await message.add_reaction(e)
            except Exception:
                pass

    async def expire_message_if_unclaimed(self, message_id: int):
        await asyncio.sleep(CLAIM_WINDOW_S)
        drop = self.bot.active_drops.get(message_id)
        if not drop or drop.get("claimed"):
            return

        drop["claimed"] = True
        try:
            channel = self.bot.get_channel(drop["channel_id"]) or await self.bot.fetch_channel(drop["channel_id"])
            msg = await channel.fetch_message(message_id)

            original = msg.content or ""
            newline = "\n" if original and not original.endswith("\n") else ""
            expired_text = "*This drop has expired and the cards can no longer be grabbed.*"
            await msg.edit(content=f"{original}{newline}{expired_text}")
        except Exception:
            pass
        finally:
            self.bot.active_drops.pop(message_id, None)

    async def _wishlist_mentions_for_cards(self, guild: discord.Guild, cards: list[dict]) -> list[str]:
        user_ids: set[int] = set()
        for c in cards:
            series = c.get("series")
            character = c.get("character")
            if not series or not character:
                continue
            try:
                wishers = await self.bot.db.get_wishers_for(series, character)
                user_ids.update(wishers)
            except Exception:
                continue

        if not guild:
            return [f"<@{uid}>" for uid in sorted(user_ids)]

        mentions: list[str] = []
        for uid in sorted(user_ids):
            try:
                member = guild.get_member(uid) or await guild.fetch_member(uid)
                if member:
                    mentions.append(member.mention)
                    continue
            except Exception:
                pass
            mentions.append(f"<@{uid}>")
        return mentions

    @app_commands.command(name="drop", description="Drop 3 cards in this channel.")
    async def slash_drop(self, interaction: discord.Interaction):
        ch_id = interaction.channel_id
        active = await self._get_active_drop_channel(interaction.guild_id)
        if active is not None and ch_id != active:
            return await interaction.response.send_message(f"Drops are only allowed in <#{active}>.", ephemeral=True)

        cd = await self._cooldown_for(interaction.guild_id)
        now = time.time()
        last = self.bot.channel_cooldowns.get(ch_id, 0)
        if now - last < cd:
            remain = int(cd - (now - last))
            return await interaction.response.send_message(
                f"Please wait {remain}s before dropping again in this channel.",
                ephemeral=True
            )

        await self.bot.db.ensure_user(interaction.user.id)
        cards = await self.create_three_cards(interaction.user.id, interaction.guild_id)

        img_bytes = await render_drop_triptych(self.bot.db, cards)
        file = discord.File(io.BytesIO(img_bytes), filename="drop.webp")

        mentions = await self._wishlist_mentions_for_cards(interaction.guild, cards)
        lead = f"A card from your wishlist is dropping! {' '.join(mentions)}\n" if mentions else ""

        content = f"{lead}{interaction.user.mention} is dropping 3 cards!"
        await interaction.response.send_message(content=content, file=file)
        msg = await interaction.original_response()

        start_ts = time.time()
        self.bot.active_drops[msg.id] = {
            "cards": [c["card_uid"] for c in cards],
            "dropped_at": start_ts,
            "channel_id": ch_id,
            "guild_id": interaction.guild_id,
            "owner_id": interaction.user.id,
            "claimed": False,
        }
        self.bot.channel_cooldowns[ch_id] = now

        try:
            await self.bot.db.set_timer(interaction.user.id, "drop")
        except Exception:
            pass

        asyncio.create_task(self.add_number_reactions(msg))
        asyncio.create_task(self.expire_message_if_unclaimed(msg.id))

    @commands.command(name="d", aliases=["md"])
    async def cmd_drop(self, ctx: commands.Context):
        ch_id = ctx.channel.id
        active = await self._get_active_drop_channel(ctx.guild.id)
        if active is not None and ch_id != active:
            return await ctx.send(f"Drops are only allowed in <#{active}>.")

        cd = await self._cooldown_for(ctx.guild.id)
        now = time.time()
        last = self.bot.channel_cooldowns.get(ch_id, 0)
        if now - last < cd:
            remain = int(cd - (now - last))
            return await ctx.send(f"Please wait {remain}s before dropping again in this channel.")

        await self.bot.db.ensure_user(ctx.author.id)
        cards = await self.create_three_cards(ctx.author.id, ctx.guild.id)

        img_bytes = await render_drop_triptych(self.bot.db, cards)
        file = discord.File(io.BytesIO(img_bytes), filename="drop.webp")

        mentions = await self._wishlist_mentions_for_cards(ctx.guild, cards)
        lead = f"A card from your wishlist is dropping! {' '.join(mentions)}\n" if mentions else "" 

        content = f"{lead}{ctx.author.mention} is dropping 3 cards!"
        sent = await ctx.send(content=content, file=file)

        start_ts = time.time()
        self.bot.active_drops[sent.id] = {
            "cards": [c["card_uid"] for c in cards],
            "dropped_at": start_ts,
            "channel_id": ch_id,
            "guild_id": ctx.guild.id,
            "owner_id": ctx.author.id,
            "claimed": False,
        }
        self.bot.channel_cooldowns[ch_id] = now

        try:
            await self.bot.db.set_timer(ctx.author.id, "drop")
        except Exception:
            pass

        asyncio.create_task(self.add_number_reactions(sent))
        asyncio.create_task(self.expire_message_if_unclaimed(sent.id))

    @commands.Cog.listener()
    async def on_raw_reaction_add(self, payload: discord.RawReactionActionEvent):
        if not self.bot.user or payload.user_id == self.bot.user.id:
            return

        drop = self.bot.active_drops.get(payload.message_id)
        if not drop or drop.get("claimed"):
            return

        emoji = str(payload.emoji)
        if emoji not in EMOJIS:
            return

        now = time.time()
        if now - drop["dropped_at"] > CLAIM_WINDOW_S:
            drop["claimed"] = True
            try:
                channel = self.bot.get_channel(drop["channel_id"]) or await self.bot.fetch_channel(drop["channel_id"])
                msg = await channel.fetch_message(payload.message_id)
                original = msg.content or ""
                newline = "\n" if original and not original.endswith("\n") else ""
                expired_text = "*This drop has expired and the cards can no longer be grabbed.*"
                await msg.edit(content=f"{original}{newline}{expired_text}")
            except Exception:
                pass
            self.bot.active_drops.pop(payload.message_id, None)
            return

        idx = EMOJIS.index(emoji)
        if idx >= len(drop["cards"]):
            return
        card_uid = drop["cards"][idx]

        raw_delay = now - drop["dropped_at"]
        latency = float(getattr(self.bot, "latency", 0.0) or 0.0)
        delay = round(max(0.0, raw_delay - latency), 2)

        ok = await self.bot.db.claim_card(card_uid, payload.user_id, delay)
        if not ok:
            drop["claimed"] = True
            self.bot.active_drops.pop(payload.message_id, None)
            return

        drop["claimed"] = True
        try:
            channel = self.bot.get_channel(drop["channel_id"]) or await self.bot.fetch_channel(drop["channel_id"])
            card = await self.bot.db.get_card(card_uid)
            condition = (card.get("condition") or "unknown").strip()
            who = f"<@{payload.user_id}>"
            char_name = card.get("character") or "Unknown"
            ann = f"{who} took the **{char_name}** card `{card_uid}`! Unfortunately, it was **{condition}**."
            await channel.send(ann)

            try:
                await self.bot.db.set_timer(payload.user_id, "grab")
            except Exception:
                pass

        except Exception:
            pass
        finally:
            self.bot.active_drops.pop(payload.message_id, None)


async def setup(bot: commands.Bot):
    await bot.add_cog(DropsCog(bot))


# ===== menami\cogs\helpcmd.py =====

from __future__ import annotations
import discord
from discord.ext import commands
from ..config import (
    DROP_COOLDOWN_S,
    CLAIM_WINDOW_S,
    STAR_WEIGHTS,
    UPGRADE_RULES,
)

def _star_label(n: int) -> str:
    filled = "★" * n
    empty = "☆" * (4 - n)
    return filled + empty

def _drop_odds_line() -> str:
    total = float(sum(STAR_WEIGHTS)) if STAR_WEIGHTS else 0.0
    try:
        parts = []
        for i, w in enumerate(STAR_WEIGHTS):
            pct = (float(w) / total * 100.0) if total > 0 else 0.0
            parts.append(f"{_star_label(i)} ~{pct:.0f}%")
        return "Drop odds: " + " · ".join(parts)
    except Exception:
        return "Drop odds: evenly weighted (config error reading STAR_WEIGHTS)"

def _upgrade_rules_lines() -> list[str]:
    lines = []
    order = sorted(UPGRADE_RULES.keys())
    names = {0: "damaged", 1: "poor", 2: "good", 3: "excellent", 4: "mint"}
    for curr in order:
        r = UPGRADE_RULES[curr]
        to = r["to"]
        chance = int(round(float(r["chance"]) * 100))
        gold = int(r["gold"])
        dust = int(r["dust"])
        dust_stars = _star_label(to)
        fail_txt = "stay" if str(r.get("fail", "stay")) == "stay" else "damaged"
        lines.append(
            f"- {names[curr]} → {names[to]}: {chance}% • -{dust} Dust ({dust_stars}) • -{gold} Gold • fail: {fail_txt}"
        )
    lines.append("- mint: already max")
    return lines

def build_help_embed() -> discord.Embed:
    e = discord.Embed(
        title="📖 MenamiBot Help",
        description=(
            f"Drop cooldown: `{DROP_COOLDOWN_S}s` • Claim window: `{CLAIM_WINDOW_S}s`\n"
            "React with **1️⃣ 2️⃣ 3️⃣** to claim a card."
        ),
        color=discord.Color.blurple(),
    )

    # Drops section
    e.add_field(
        name="🎴 Drops & Claiming",
        value=(
            "`md` — Drop 3 cards\n"
            "React **1️⃣2️⃣3️⃣** to claim\n"
            f"{_drop_odds_line()}"
        ),
        inline=False,
    )

    # Economy
    e.add_field(
        name="💰 Economy",
        value=(
            "`mb` — Burn latest/UID (coins + 1 dust by ★)\n"
            "`mi` — Show inventory\n"
            "`mdaily` — Claim your daily (coins + gems)"
        ),
        inline=False,
    )

    # Cooldowns (NEW)
    e.add_field(
        name="⏱️ Cooldowns",
        value=(
            "`mcd` — Your cooldowns (drop / grab / daily)\n"
            "`mscd` — Server drop cooldown (admins)"
        ),
        inline=False,
    )

    # Upgrades
    e.add_field(
        name="🛠️ Upgrades",
        value=(
            "`mup` — Upgrade latest/UID (or use **/upgrade**)\n"
            "Press 🔨 to attempt (costs dust + gold)\n"
            + "\n".join(_upgrade_rules_lines())
        ),
        inline=False,
    )

    # Collection
    e.add_field(
        name="🗂️ Collection",
        value=(
            "`mc` — Show collection\n"
            "Filters: `s:` series • `c:` char • `q:` stars\n"
            "`q>= / q<=` • `t:` tag (`none`=untagged)\n"
            "`e:` edition • `o:s` sort series"
        ),
        inline=False,
    )

    # Tags
    e.add_field(
        name="🏷️ Tags",
        value=(
            "`tags` — List\n"
            "`tc <name> <emoji>` — Create\n"
            "`td <name>` — Delete\n"
            "`t <tag> [uid]` — Tag a card\n"
            "`ut [uid]` — Remove tag"
        ),
        inline=False,
    )

    # Cards / transfer
    e.add_field(
        name="🔎 Cards",
        value=(
            "`mv` — View card (UID or latest)\n"
            "`ci` — Detailed card info\n"
            "Use **/give** to transfer a card"
        ),
        inline=False,
    )

    # Lookup
    e.add_field(
        name="📊 Lookup",
        value=(
            "`mlu` — Character stats\n"
            "Format: `Series | Character`\n"
            "Shows totals, claim rate, editions"
        ),
        inline=False,
    )

    # Quick ref
    e.add_field(
        name="⚡ Quick Ref",
        value=(
            "`md mc mi mv ci mlu mb mdaily mcd mscd mup tags tc td t ut`"
        ),
        inline=False,
    )

    return e

class HelpCog(commands.Cog):
    def __init__(self, bot: commands.Bot):
        self.bot = bot

    @commands.command(name="help", aliases=["mhelp"])
    async def cmd_help(self, ctx: commands.Context):
        await ctx.send(embed=build_help_embed())

async def setup(bot: commands.Bot):
    await bot.add_cog(HelpCog(bot))


# ===== menami\cogs\inventory.py =====

from __future__ import annotations
import shlex
from typing import List, Tuple
import discord
from discord import app_commands
from discord.ext import commands
import io, os, re
from discord.ext import commands

from ..card_render import render_card_image

from ..embeds import (
    format_card_embed,
    build_simple_cardinfo_embed,
    build_character_lookup_embed,
    build_burn_preview_embed,
    build_upgrade_preview_embed,
)
from ..views import (
    InventoryView,
    CollectionView,
    ConfirmBurnView,
    balances_to_items,
    UpgradeView,
    EditionLookupView,
)

def self_or_manage_guild():
    async def predicate(ctx: commands.Context):
        return ctx.author.id == ctx.bot.user.id or ctx.author.guild_permissions.manage_guild
    return commands.check(predicate)

async def _render_attachment(bot, card):
    url = await bot.db.get_character_image(card["series"], card["character"], int(card["set_id"]))
    if not url:
        url = await bot.db.get_character_image_any(card["series"], card["character"])

    img_bytes = await render_card_image(
        series=card["series"],
        character=card["character"],
        serial_number=int(card["serial_number"]),
        set_id=int(card["set_id"]),
        card_uid=card["card_uid"],
        image_url=url,
        fmt="PNG",
    )
    fname = f"{card['card_uid']}.png"
    return discord.File(io.BytesIO(img_bytes), filename=fname), fname

def parse_collection_filters(text: str) -> dict:
    f: dict = {}
    if not text:
        return f

    try:
        tokens = shlex.split(text)
    except ValueError:
        tokens = text.split()

    for raw in tokens:
        arg = raw.strip()
        if not arg:
            continue

        low = arg.lower()

        if low.startswith("s:"):
            f["s"] = arg[2:].strip(); continue

        if low.startswith("c:"):
            f["c"] = arg[2:].strip(); continue

        if low.startswith("q>="):
            try:
                f["q_op"] = ">="; f["q_val"] = int(arg[3:])
            except ValueError: pass
            continue

        if low.startswith("q<="):
            try:
                f["q_op"] = "<="; f["q_val"] = int(arg[3:])
            except ValueError: pass
            continue

        if low.startswith("q:"):
            try:
                f["q"] = int(arg[2:])
            except ValueError: pass
            continue

        if low.startswith("o:"):
            val = low[2:]
            f["o"] = "s" if val in ("s", "series") else "d"
            continue

        if low.startswith("t:"):
            val = arg[2:].strip()
            f["t"] = "none" if val.lower() == "none" else val
            continue

        if low.startswith("e:"):
            try:
                f["e"] = int(arg[2:])
            except ValueError: pass
            continue

    return f

class InventoryCog(commands.Cog):
    def __init__(self, bot: commands.Bot):
        self.bot = bot

    # -------- Collection --------
    @app_commands.command(name="collection", description="Show a user's collection.")
    @app_commands.describe(user="User to view, defaults to you")
    async def slash_collection(self, interaction: discord.Interaction, user: discord.User | None = None):
        target = user or interaction.user
        rows = await self.bot.db.inventory(target.id)
        if not rows:
            return await interaction.response.send_message(f"{target.mention} has no cards yet.", ephemeral=True)
        view = CollectionView(self.bot, target, rows, ephemeral=True)
        await interaction.response.send_message(embed=view.build_embed(), view=view, ephemeral=False)

    @commands.command(name="c", aliases=["mc"])
    async def cmd_collection(self, ctx: commands.Context, *, filters_text: str | None = None):
        target = ctx.author
        if not filters_text or not filters_text.strip():
            rows = await self.bot.db.inventory(target.id)
        else:
            flt = parse_collection_filters(filters_text)
            rows = await self.bot.db.inventory_filtered(target.id, flt)

        if not rows:
            msg = f"{target.mention} has no cards yet." if not filters_text else f"{target.mention} has no cards matching filters."
            return await ctx.send(msg)

        view = CollectionView(self.bot, target, rows)
        await ctx.send(embed=view.build_embed(), view=view)

    @commands.command(name="imgset", aliases=["mimgset"])
    @self_or_manage_guild()
    async def cmd_imgset(self, ctx, edition: int, *, query: str):
        parts = [p.strip() for p in query.split("|")]
        if len(parts) < 2 or len(parts) > 3:
            return await ctx.send("Format: `mimgset <edition> Series | Character` or `mimgset <edition> Series | Character | <url-or-file>`")

        series, character = parts[0], parts[1]
        src = parts[2] if len(parts) == 3 else None

        url = None
        size = None
        mime = None

        if ctx.message.attachments:
            a = ctx.message.attachments[0]
            url = a.url
            size = a.size
            mime = a.content_type
        elif src:
            low = src.lower()
            if low.startswith("file://") or (os.name == "nt" and re.match(r"^[a-zA-Z]:[\\/]", src)) or (src.startswith("/") and os.name != "nt"):
                path = src
                if low.startswith("file://"):
                    path = src.replace("file://", "", 1)
                    if os.name == "nt" and path.startswith("/"):
                        path = path[1:]
                path = path.strip().strip('"')
                if not os.path.exists(path):
                    return await ctx.send("File not found.")
                try:
                    temp_msg = await ctx.send(file=discord.File(path))
                    if not temp_msg.attachments:
                        return await ctx.send("Upload failed.")
                    att = temp_msg.attachments[0]
                    url = att.url
                    size = att.size
                    mime = att.content_type
                    try:
                        await temp_msg.delete()
                    except Exception:
                        pass
                except Exception as e:
                    return await ctx.send(f"Upload error: {e}")
            elif low.startswith("http://") or low.startswith("https://"):
                url = src
            else:
                return await ctx.send("Third argument must be a `file://` path, absolute path, or http(s) URL.")
        else:
            return await ctx.send("Please attach an image or provide `| <url-or-file>`.")

        if size and size > 200_000:
            return await ctx.send("⚠️ Keep images ≤ 200KB.")

        await self.bot.db.set_character_image(series, character, int(edition), url, size, mime)
        await ctx.send(f"✅ Image set for {character} · {series} · ◈{edition}")

    # -------- Inventory --------
    @app_commands.command(name="inventory", description="Show your items (coin, gem, ticket) with pagination.")
    @app_commands.describe(user="User to view, defaults to you")
    async def slash_inventory(self, interaction: discord.Interaction, user: discord.User | None = None):
        target = user or interaction.user
        bal = await self.bot.db.get_items(target.id)
        items_all = balances_to_items(bal)
        view = InventoryView(self.bot, target, items_all, ephemeral=True)
        await interaction.response.send_message(embed=view.build_embed(), view=view, ephemeral=False)

    @commands.command(name="i", aliases=["mi"])
    async def cmd_inventory_items(self, ctx: commands.Context, member: discord.Member | None = None):
        target = member or ctx.author
        bal = await self.bot.db.get_items(target.id)
        items_all = balances_to_items(bal)
        view = InventoryView(self.bot, target, items_all)
        await ctx.send(embed=view.build_embed(), view=view)

    # -------- View / Give --------
    @app_commands.command(name="view", description="View a card by its ID.")
    @app_commands.describe(card_id="Card UID (leave empty for latest)")
    async def slash_view(self, interaction: discord.Interaction, card_id: str | None = None):
        if card_id:
            card = await self.bot.db.get_card(card_id.strip())
        else:
            card = await self.bot.db.get_latest_card(interaction.user.id)
        if not card:
            return await interaction.response.send_message("Card not found.", ephemeral=True)

        embed = format_card_embed(card, claimed=card["grabbed_by"] is not None)

        try:
            attach = await _render_attachment(self.bot, card)
        except Exception:
            attach = None

        if attach:
            file, fname = attach
            embed.set_image(url=f"attachment://{fname}")
            await interaction.response.send_message(embed=embed, file=file)
        else:
            await interaction.response.send_message(embed=embed)

    # -------- Burn --------
    @app_commands.command(name="burn", description="Burn a card for coins and dust (with confirmation).")
    @app_commands.describe(card_id="Card UID (leave empty for latest)")
    async def slash_burn(self, interaction: discord.Interaction, card_id: str | None = None):
        if card_id:
            card = await self.bot.db.get_card(card_id.strip())
        else:
            card = await self.bot.db.get_latest_card(interaction.user.id)

        if not card:
            return await interaction.response.send_message("Card not found.", ephemeral=True)
        if card.get("owned_by") != str(interaction.user.id):
            return await interaction.response.send_message("You don't own that card.", ephemeral=True)

        stars = int(card["stars"])
        embed = build_burn_preview_embed(interaction.user, stars)

        file = None
        fname = None
        try:
            url = await self.bot.db.get_character_image(card["series"], card["character"], int(card["set_id"])) \
                or await self.bot.db.get_character_image_any(card["series"], card["character"])
            img_bytes = await render_card_image(
                series=card["series"],
                character=card["character"],
                serial_number=int(card["serial_number"]),
                set_id=int(card["set_id"]),
                card_uid=card["card_uid"],
                image_url=url,
                fmt="PNG",
            )
            fname = f"{card['card_uid']}.png"
            file = discord.File(io.BytesIO(img_bytes), filename=fname)
            embed.set_thumbnail(url=f"attachment://{fname}")
        except Exception:
            pass

        view = ConfirmBurnView(self.bot, interaction.user.id, card["card_uid"], stars)
        if file:
            await interaction.response.send_message(embed=embed, view=view, file=file)
        else:
            await interaction.response.send_message(embed=embed, view=view)
        sent = await interaction.original_response()
        view.message = sent

    @commands.command(name="b", aliases=["mb"])
    async def cmd_burn(self, ctx: commands.Context, card_id: str | None = None):
        if card_id:
            card = await self.bot.db.get_card(card_id.strip())
        else:
            card = await self.bot.db.get_latest_card(ctx.author.id)

        if not card:
            return await ctx.send("Card not found.")
        if card.get("owned_by") != str(ctx.author.id):
            return await ctx.send("You don't own that card.")

        stars = int(card["stars"])
        embed = build_burn_preview_embed(ctx.author, stars)

        file = None
        fname = None
        try:
            url = await self.bot.db.get_character_image(card["series"], card["character"], int(card["set_id"])) \
                or await self.bot.db.get_character_image_any(card["series"], card["character"])
            img_bytes = await render_card_image(
                series=card["series"],
                character=card["character"],
                serial_number=int(card["serial_number"]),
                set_id=int(card["set_id"]),
                card_uid=card["card_uid"],
                image_url=url,
                fmt="PNG",
            )
            fname = f"{card['card_uid']}.png"
            file = discord.File(io.BytesIO(img_bytes), filename=fname)
            embed.set_thumbnail(url=f"attachment://{fname}")
        except Exception:
            pass

        view = ConfirmBurnView(self.bot, ctx.author.id, card["card_uid"], stars)
        if file:
            sent = await ctx.send(embed=embed, view=view, file=file)
        else:
            sent = await ctx.send(embed=embed, view=view)
        view.message = sent

    # -------- Upgrade --------
    @app_commands.command(name="upgrade", description="Preview and attempt an upgrade for a card.")
    @app_commands.describe(card_id="Card UID (leave empty for latest)")
    async def slash_upgrade(self, interaction: discord.Interaction, card_id: str | None = None):
        if card_id:
            card = await self.bot.db.get_card(card_id.strip())
        else:
            card = await self.bot.db.get_latest_card(interaction.user.id)

        if not card:
            return await interaction.response.send_message("Card not found.", ephemeral=True)
        if card.get("owned_by") != str(interaction.user.id):
            return await interaction.response.send_message("You don't own that card.", ephemeral=True)

        preview = build_upgrade_preview_embed(interaction.user, card)
        view = UpgradeView(self.bot, interaction.user.id, card["card_uid"])
        await interaction.response.send_message(embed=preview, view=view)
        sent = await interaction.original_response()
        view.message = sent

    @commands.command(name="upgrade", aliases=["mup", "up"])
    async def cmd_upgrade(self, ctx: commands.Context, card_id: str | None = None):
        if card_id:
            card = await self.bot.db.get_card(card_id.strip())
        else:
            card = await self.bot.db.get_latest_card(ctx.author.id)

        if not card:
            return await ctx.send("Card not found.")
        if card.get("owned_by") != str(ctx.author.id):
            return await ctx.send("You don't own that card.")

        preview = build_upgrade_preview_embed(ctx.author, card)
        view = UpgradeView(self.bot, ctx.author.id, card["card_uid"])
        sent = await ctx.send(embed=preview, view=view)
        view.message = sent

    # -------- Misc view helpers --------
    @commands.command(name="view", aliases=["mv", "v"])
    async def cmd_view(self, ctx: commands.Context, card_id: str | None = None):
        if card_id:
            card = await self.bot.db.get_card(card_id.strip())
        else:
            card = await self.bot.db.get_latest_card(ctx.author.id)

        if not card:
            return await ctx.send("Card not found.")

        embed = build_simple_cardinfo_embed(card)
        attach = await _render_attachment(self.bot, card)
        if attach:
            file, fname = attach
            embed.set_image(url=f"attachment://{fname}")
            await ctx.send(embed=embed, file=file)
        else:
            await ctx.send(embed=embed)

    @commands.command(name="cardinfo", aliases=["ci"])
    async def cmd_cardinfo(self, ctx: commands.Context, card_id: str | None = None):
        if card_id:
            card = await self.bot.db.get_card(card_id.strip())
        else:
            card = await self.bot.db.get_latest_card(ctx.author.id)

        if not card:
            return await ctx.send("Card not found.")

        embed = format_card_embed(card, claimed=card["grabbed_by"] is not None)
        await ctx.send(embed=embed)

    # -------- Lookup & Tags (unchanged) --------
    @commands.command(name="lookup", aliases=["mlu", "lu"])
    async def cmd_lookup(self, ctx: commands.Context, *, query: str | None = None):
        if not query:
            latest = await self.bot.db.get_latest_card(ctx.author.id)
            if not latest:
                return await ctx.send("You don't own any cards yet.")
            series = latest["series"]
            character = latest["character"]
            current_set = int(latest["set_id"])

            stats_all = await self.bot.db.character_stats(series, character, set_id=None)
            editions = stats_all["editions"]
            if editions:
                try:
                    start_index = editions.index(current_set)
                except ValueError:
                    start_index = 0
                view = EditionLookupView(
                    self.bot, series, character, editions,
                    start_index=start_index, requester_id=ctx.author.id
                )
                embed = await view.build_embed()
                sent = await ctx.send(embed=embed, view=view)
                view.message = sent
            else:
                stats = stats_all
                embed = build_character_lookup_embed(stats, edition_index=1)
                await ctx.send(embed=embed)
            return

        parts = [p.strip() for p in query.split("|")]
        if len(parts) != 2:
            return await ctx.send("Format: `Series | Character` (or just `mlu` for your latest card)")

        series, character = parts
        stats_all = await self.bot.db.character_stats(series, character, set_id=None)
        editions = stats_all["editions"]
        if editions:
            view = EditionLookupView(self.bot, series, character, editions, start_index=0)
            embed = await view.build_embed()
            sent = await ctx.send(embed=embed, view=view)
            view.message = sent
        else:
            stats = stats_all
            embed = build_character_lookup_embed(stats, edition_index=1)
            await ctx.send(embed=embed)

    @commands.command(name="tags")
    async def cmd_tags(self, ctx: commands.Context):
        tags = await self.bot.db.list_tags(ctx.author.id)
        if not tags:
            return await ctx.send("You have no tags yet. Create one with `tc <name> <emoji>`.")
        lines = [f"{t['emoji']} `{t['name']}`" for t in tags]
        await ctx.send("**Your Tags:**\n" + "\n".join(lines))

    @commands.command(name="tagcreate", aliases=["tc"])
    async def cmd_tagcreate(self, ctx: commands.Context, name: str, emoji: str):
        ok = await self.bot.db.create_tag(ctx.author.id, name, emoji)
        if not ok:
            return await ctx.send(f"⚠️ Tag `{name}` already exists.")
        await ctx.send(f"✅ Created tag `{name}` with {emoji}")

    @commands.command(name="tagdelete", aliases=["td"])
    async def cmd_tagdelete(self, ctx: commands.Context, name: str):
        ok = await self.bot.db.delete_tag(ctx.author.id, name)
        if not ok:
            return await ctx.send(f"⚠️ Tag `{name}` not found.")
        await ctx.send(f"🗑️ Deleted tag `{name}`")

    @commands.command(name="tag", aliases=["t"])
    async def cmd_tag(self, ctx: commands.Context, tag_name: str, card_uid: str | None = None):
        if not card_uid:
            latest = await self.bot.db.get_latest_card(ctx.author.id)
            if not latest:
                return await ctx.send("You don't own any cards yet.")
            card_uid = latest["card_uid"]

        card = await self.bot.db.get_card(card_uid.strip())
        if not card:
            return await ctx.send("Card not found.")
        if card["owned_by"] != str(ctx.author.id):
            return await ctx.send("You don’t own this card.")

        ok = await self.bot.db.assign_tag(ctx.author.id, card_uid.strip(), tag_name)
        if not ok:
            return await ctx.send(f"⚠️ Tag `{tag_name}` not found. Use `tc <name> <emoji>` first.")
        await ctx.send(f"✅ Tagged card `{card_uid}` with `{tag_name}`")

    @commands.command(name="untag", aliases=["ut"])
    async def cmd_untag(self, ctx: commands.Context, card_uid: str | None = None):
        if not card_uid:
            latest = await self.bot.db.get_latest_card(ctx.author.id)
            if not latest:
                return await ctx.send("You don't own any cards yet.")
            card_uid = latest["card_uid"]

        card = await self.bot.db.get_card(card_uid.strip())
        if not card:
            return await ctx.send("Card not found.")
        if card["owned_by"] != str(ctx.author.id):
            return await ctx.send("You don’t own this card.")

        await self.bot.db.untag_card(card_uid.strip())
        await ctx.send(f"✅ Removed tag from `{card_uid}`")

async def setup(bot: commands.Bot):
    await bot.add_cog(InventoryCog(bot))


# ===== menami\cogs\settings.py =====

from __future__ import annotations
import discord
from discord import app_commands
from discord.ext import commands

class SettingsCog(commands.Cog):
    def __init__(self, bot: commands.Bot):
        self.bot = bot

    @app_commands.command(name="mset", description="Set the active channel where cards can drop. Omit to use current channel.")
    @app_commands.describe(channel="Channel to allow drops in")
    async def slash_mset(self, interaction: discord.Interaction, channel: discord.TextChannel | None = None):
        if not interaction.user.guild_permissions.manage_guild and not interaction.user.guild_permissions.administrator:
            return await interaction.response.send_message("You need Manage Server permission.", ephemeral=True)
        ch = channel or interaction.channel
        if not isinstance(ch, discord.TextChannel):
            return await interaction.response.send_message("Pick a text channel.", ephemeral=True)
        await self.bot.db.set_drop_channel(interaction.guild_id, ch.id)
        await interaction.response.send_message(f"Active drop channel set to {ch.mention}.")

    @commands.command(name="set", aliases=["mset"])
    async def cmd_mset(self, ctx: commands.Context, channel: discord.TextChannel | None = None):
        if not ctx.author.guild_permissions.manage_guild and not ctx.author.guild_permissions.administrator:
            return await ctx.send("You need Manage Server permission.")
        ch = channel or ctx.channel
        if not isinstance(ch, discord.TextChannel):
            return await ctx.send("Pick a text channel.")
        await self.bot.db.set_drop_channel(ctx.guild.id, ch.id)
        await ctx.send(f"Active drop channel set to {ch.mention}.")

    @app_commands.command(name="servercooldown", description="Set or reset the drop cooldown for this server.")
    @app_commands.describe(seconds="Cooldown in seconds (5–3600). Omit to view, 0 to reset to default.")
    async def slash_servercooldown(self, interaction: discord.Interaction, seconds: int | None = None):
        if not interaction.user.guild_permissions.manage_guild and not interaction.user.guild_permissions.administrator:
            return await interaction.response.send_message("You need Manage Server permission.", ephemeral=True)
        if seconds is None:
            cur = await self.bot.db.get_drop_cooldown(interaction.guild_id)
            return await interaction.response.send_message(f"Current drop cooldown: {cur if cur is not None else 'default'}s", ephemeral=True)
        if seconds == 0:
            await self.bot.db.set_drop_cooldown(interaction.guild_id, None)
            return await interaction.response.send_message("Drop cooldown reset to default.")
        if seconds < 5 or seconds > 3600:
            return await interaction.response.send_message("Cooldown must be between 5 and 3600 seconds.", ephemeral=True)
        await self.bot.db.set_drop_cooldown(interaction.guild_id, seconds)
        await interaction.response.send_message(f"Drop cooldown set to {seconds}s.")

    @commands.command(name="servercooldown", aliases=["scd", "mscd"])
    async def cmd_servercooldown(self, ctx: commands.Context, seconds: int | None = None):
        if not ctx.author.guild_permissions.manage_guild and not ctx.author.guild_permissions.administrator:
            return await ctx.send("You need Manage Server permission.")
        if seconds is None:
            cur = await self.bot.db.get_drop_cooldown(ctx.guild.id)
            return await ctx.send(f"Current drop cooldown: {cur if cur is not None else 'default'}s")
        if seconds == 0:
            await self.bot.db.set_drop_cooldown(ctx.guild.id, None)
            return await ctx.send("Drop cooldown reset to default.")
        if seconds < 5 or seconds > 3600:
            return await ctx.send("Cooldown must be between 5 and 3600 seconds.")
        await self.bot.db.set_drop_cooldown(ctx.guild.id, seconds)
        await ctx.send(f"Drop cooldown set to {seconds}s.")

async def setup(bot: commands.Bot):
    await bot.add_cog(SettingsCog(bot))


# ===== menami\cogs\wishlist.py =====

from __future__ import annotations
import math
import shlex
from typing import Optional

import discord
from discord.ext import commands

from ..config import WISHLIST_MAX

def _page_range_text(page: int, total: int, page_size: int, noun: str) -> str:
    if total == 0:
        return f"Showing {noun} 0–0 of 0"
    start = page * page_size + 1
    end = min((page + 1) * page_size, total)
    return f"Showing {noun} {start}–{end} of {total}"

def _parse_query(text: str) -> tuple[Optional[str], str]:
    if "|" in text:
        parts = [p.strip() for p in text.split("|", 1)]
        if len(parts) == 2 and parts[0] and parts[1]:
            return parts[0], parts[1]
    return None, text.strip()

class WishlistCog(commands.Cog):
    def __init__(self, bot: commands.Bot):
        self.bot = bot

    @commands.command(name="wishlist", aliases=["wl","mwl"])
    async def cmd_wishlist(self, ctx: commands.Context, member: Optional[discord.Member] = None, page: int = 0):
        target = member or ctx.author
        items = await self.bot.db.list_wishlist(target.id)
        total = len(items)

        page_size = 10
        pages = max(1, math.ceil(total / page_size))
        page = max(0, min(page, pages - 1))
        start = page * page_size
        end = start + page_size
        slice_ = items[start:end]

        lines = [f"{s} · {c}" for (s, c) in slice_] if slice_ else ["_No characters on wishlist._"]
        left = max(0, WISHLIST_MAX - total)

        desc = [
            f"Showing wishlist of {target.mention}",
            f"Available slots: {left}/{WISHLIST_MAX}",
            "",
            "\n".join(lines),
            "",
            _page_range_text(page, total, page_size, "characters")
        ]
        e = discord.Embed(title="Wishlist", description="\n".join(desc), color=discord.Color.blurple())
        await ctx.send(embed=e)

    @commands.command(name="wishadd", aliases=["wa","mwa"])
    async def cmd_wishadd(self, ctx: commands.Context, *, query: str):
        query = query.strip()
        if not query:
            return await ctx.send("Usage: `mwa Series | Character` or `mwa Character`")

        count = await self.bot.db.wishlist_count(ctx.author.id)
        if count >= WISHLIST_MAX:
            return await ctx.send(f"Your wishlist is full ({WISHLIST_MAX}). Remove an entry with `mwr` first.")

        series_raw, char_raw = _parse_query(query)
        to_add: list[tuple[str, str]] = []

        if series_raw:
            found = await self.bot.db.find_canonical_series_character(series_raw, char_raw)
            if not found:
                return await ctx.send("I couldn't find that series/character. Use `Series | Character` with exact names.")
            to_add = [found]
        else:
            matches = await self.bot.db.find_by_character_only(char_raw)
            if not matches:
                return await ctx.send("I couldn't find that character. Try `Series | Character`.")
            to_add = [matches[0]]
            if len(matches) > 1:
                alt = ", ".join(f"{s} · {c}" for s, c in matches[:5])
                await ctx.send(f"Note: multiple matches for `{char_raw}`. Added **{matches[0][0]} · {matches[0][1]}**.\n"
                               f"To pick a specific series next time, use: `mwa Series | {char_raw}`\n"
                               f"Examples: {alt}")

        added = 0
        for s, c in to_add:
            ok = await self.bot.db.add_wish(ctx.author.id, s, c)
            if ok:
                added += 1

        new_count = await self.bot.db.wishlist_count(ctx.author.id)
        left = max(0, WISHLIST_MAX - new_count)
        if added:
            return await ctx.send(f"✅ Added to wishlist. Slots left: {left}/{WISHLIST_MAX}")
        else:
            return await ctx.send("That entry already exists on your wishlist.")

    @commands.command(name="wishremove", aliases=["wr","mwr"])
    async def cmd_wishremove(self, ctx: commands.Context, *, query: str):
        query = query.strip()
        if not query:
            return await ctx.send("Usage: `mwr Series | Character` or `mwr Character` (removes all matches)")
        series_raw, char_raw = _parse_query(query)

        removed = await self.bot.db.remove_wish(ctx.author.id, series_raw, char_raw)
        if removed <= 0:
            return await ctx.send("No matching wishlist entry found.")
        else:
            count = await self.bot.db.wishlist_count(ctx.author.id)
            left = max(0, WISHLIST_MAX - count)
            spec = f"{series_raw} · {char_raw}" if series_raw else char_raw
            return await ctx.send(f"🗑️ Removed {removed} entr{'y' if removed==1 else 'ies'} for `{spec}`. Slots left: {left}/{WISHLIST_MAX}")

async def setup(bot: commands.Bot):
    await bot.add_cog(WishlistCog(bot))
